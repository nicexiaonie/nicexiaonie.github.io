[toc]
# 算法面试题集 

## 一、数组和字符串算法

### 1.1 两数之和
**题目**: 给定一个整数数组和目标值，找出数组中和为目标值的两个数的索引。

**解法**:
```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    for i, num := range nums {
        if j, ok := m[target-num]; ok {
            return []int{j, i}
        }
        m[num] = i
    }
    return nil
}
```

**时间复杂度**: O(n)
**空间复杂度**: O(n)

### 1.2 三数之和
**题目**: 给定数组，找出所有和为0的三元组。

**解法**:
```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
    result := [][]int{}

    for i := 0; i < len(nums)-2; i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i+1, len(nums)-1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                result = append(result, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                for left < right && nums[right] == nums[right-1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return result
}
```

### 1.3 最长无重复子串
**题目**: 找出字符串中最长的无重复字符子串长度。

**解法**:
```go
func lengthOfLongestSubstring(s string) int {
    m := make(map[byte]int)
    maxLen, left := 0, 0

    for right := 0; right < len(s); right++ {
        if idx, ok := m[s[right]]; ok && idx >= left {
            left = idx + 1
        }
        m[s[right]] = right
        if right-left+1 > maxLen {
            maxLen = right - left + 1
        }
    }
    return maxLen
}
```

### 1.4 最长回文子串
**题目**: 找出字符串中最长的回文子串。

**解法**:
```go
func longestPalindrome(s string) string {
    if len(s) < 2 {
        return s
    }

    start, maxLen := 0, 1

    expandAroundCenter := func(left, right int) {
        for left >= 0 && right < len(s) && s[left] == s[right] {
            if right-left+1 > maxLen {
                start = left
                maxLen = right - left + 1
            }
            left--
            right++
        }
    }

    for i := 0; i < len(s); i++ {
        expandAroundCenter(i, i)
        expandAroundCenter(i, i+1)
    }

    return s[start : start+maxLen]
}
```

### 1.5 字符串匹配 (KMP算法)
**题目**: 实现strStr()函数，在主串中查找子串位置。

**解法**:
```go
func strStr(haystack string, needle string) int {
    if len(needle) == 0 {
        return 0
    }

    // 构建next数组
    next := make([]int, len(needle))
    j := 0
    for i := 1; i < len(needle); i++ {
        for j > 0 && needle[i] != needle[j] {
            j = next[j-1]
        }
        if needle[i] == needle[j] {
            j++
        }
        next[i] = j
    }

    // KMP匹配
    j = 0
    for i := 0; i < len(haystack); i++ {
        for j > 0 && haystack[i] != needle[j] {
            j = next[j-1]
        }
        if haystack[i] == needle[j] {
            j++
        }
        if j == len(needle) {
            return i - len(needle) + 1
        }
    }
    return -1
}
```

### 1.6 最大子数组和
**题目**: 找出数组中和最大的连续子数组。

**解法**:
```go
func maxSubArray(nums []int) int {
    maxSum := nums[0]
    currentSum := nums[0]

    for i := 1; i < len(nums); i++ {
        currentSum = max(nums[i], currentSum+nums[i])
        maxSum = max(maxSum, currentSum)
    }
    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### 1.7 合并区间
**题目**: 合并所有重叠的区间。

**解法**:
```go
func merge(intervals [][]int) [][]int {
    if len(intervals) <= 1 {
        return intervals
    }

    sort.Slice(intervals, func(i, j int) bool {
        return intervals[i][0] < intervals[j][0]
    })

    result := [][]int{intervals[0]}

    for i := 1; i < len(intervals); i++ {
        last := result[len(result)-1]
        if intervals[i][0] <= last[1] {
            last[1] = max(last[1], intervals[i][1])
        } else {
            result = append(result, intervals[i])
        }
    }
    return result
}
```

### 1.8 旋转数组
**题目**: 将数组向右旋转k步。

**解法**:
```go
func rotate(nums []int, k int) {
    k %= len(nums)
    reverse := func(arr []int, start, end int) {
        for start < end {
            arr[start], arr[end] = arr[end], arr[start]
            start++
            end--
        }
    }

    reverse(nums, 0, len(nums)-1)
    reverse(nums, 0, k-1)
    reverse(nums, k, len(nums)-1)
}
```

### 1.9 接雨水
**题目**: 计算能接多少雨水。

**解法**:
```go
func trap(height []int) int {
    if len(height) == 0 {
        return 0
    }

    left, right := 0, len(height)-1
    leftMax, rightMax := 0, 0
    water := 0

    for left < right {
        if height[left] < height[right] {
            if height[left] >= leftMax {
                leftMax = height[left]
            } else {
                water += leftMax - height[left]
            }
            left++
        } else {
            if height[right] >= rightMax {
                rightMax = height[right]
            } else {
                water += rightMax - height[right]
            }
            right--
        }
    }
    return water
}
```

### 1.10 滑动窗口最大值
**题目**: 给定数组和窗口大小k，返回每个窗口的最大值。

**解法**:
```go
func maxSlidingWindow(nums []int, k int) []int {
    if len(nums) == 0 || k == 0 {
        return []int{}
    }

    deque := []int{}
    result := []int{}

    for i := 0; i < len(nums); i++ {
        // 移除窗口外的元素
        for len(deque) > 0 && deque[0] < i-k+1 {
            deque = deque[1:]
        }

        // 移除比当前元素小的元素
        for len(deque) > 0 && nums[deque[len(deque)-1]] < nums[i] {
            deque = deque[:len(deque)-1]
        }

        deque = append(deque, i)

        if i >= k-1 {
            result = append(result, nums[deque[0]])
        }
    }
    return result
}
```

## 二、链表算法

### 2.1 反转链表
**题目**: 反转单链表。

**解法**:
```go
type ListNode struct {
    Val  int
    Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head

    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    return prev
}
```

### 2.2 合并两个有序链表
**题目**: 合并两个升序链表。

**解法**:
```go
func mergeTwoLists(l1, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy

    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            curr.Next = l1
            l1 = l1.Next
        } else {
            curr.Next = l2
            l2 = l2.Next
        }
        curr = curr.Next
    }

    if l1 != nil {
        curr.Next = l1
    }
    if l2 != nil {
        curr.Next = l2
    }

    return dummy.Next
}
```

### 2.3 环形链表检测
**题目**: 判断链表是否有环，如果有返回入环节点。

**解法**:
```go
func detectCycle(head *ListNode) *ListNode {
    slow, fast := head, head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {
            slow = head
            for slow != fast {
                slow = slow.Next
                fast = fast.Next
            }
            return slow
        }
    }
    return nil
}
```

### 2.4 删除链表倒数第N个节点
**题目**: 删除链表倒数第n个节点。

**解法**:
```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Next: head}
    fast, slow := dummy, dummy

    for i := 0; i <= n; i++ {
        fast = fast.Next
    }

    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }

    slow.Next = slow.Next.Next
    return dummy.Next
}
```

### 2.5 链表排序
**题目**: 对链表进行排序（归并排序）。

**解法**:
```go
func sortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }

    slow, fast := head, head.Next
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    mid := slow.Next
    slow.Next = nil

    left := sortList(head)
    right := sortList(mid)

    return mergeTwoLists(left, right)
}
```

### 2.6 复制带随机指针的链表
**题目**: 深拷贝带随机指针的链表。

**解法**:
```go
type Node struct {
    Val    int
    Next   *Node
    Random *Node
}

func copyRandomList(head *Node) *Node {
    if head == nil {
        return nil
    }

    m := make(map[*Node]*Node)

    curr := head
    for curr != nil {
        m[curr] = &Node{Val: curr.Val}
        curr = curr.Next
    }

    curr = head
    for curr != nil {
        m[curr].Next = m[curr.Next]
        m[curr].Random = m[curr.Random]
        curr = curr.Next
    }

    return m[head]
}
```

### 2.7 两数相加（链表表示）
**题目**: 两个链表表示的数字相加。

**解法**:
```go
func addTwoNumbers(l1, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry > 0 {
        sum := carry

        if l1 != nil {
            sum += l1.Val
            l1 = l1.Next
        }
        if l2 != nil {
            sum += l2.Val
            l2 = l2.Next
        }

        carry = sum / 10
        curr.Next = &ListNode{Val: sum % 10}
        curr = curr.Next
    }

    return dummy.Next
}
```

## 三、二叉树算法

### 3.1 二叉树的前中后序遍历
**题目**: 实现二叉树的三种遍历方式。

**解法**:
```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

// 前序遍历（递归）
func preorderTraversal(root *TreeNode) []int {
    result := []int{}
    var traverse func(*TreeNode)
    traverse = func(node *TreeNode) {
        if node == nil {
            return
        }
        result = append(result, node.Val)
        traverse(node.Left)
        traverse(node.Right)
    }
    traverse(root)
    return result
}

// 中序遍历（迭代）
func inorderTraversal(root *TreeNode) []int {
    result := []int{}
    stack := []*TreeNode{}
    curr := root

    for curr != nil || len(stack) > 0 {
        for curr != nil {
            stack = append(stack, curr)
            curr = curr.Left
        }
        curr = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, curr.Val)
        curr = curr.Right
    }
    return result
}

// 后序遍历（迭代）
func postorderTraversal(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }

    result := []int{}
    stack := []*TreeNode{root}

    for len(stack) > 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append([]int{node.Val}, result...)

        if node.Left != nil {
            stack = append(stack, node.Left)
        }
        if node.Right != nil {
            stack = append(stack, node.Right)
        }
    }
    return result
}
```

### 3.2 二叉树的层序遍历
**题目**: 按层遍历二叉树。

**解法**:
```go
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }

    result := [][]int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        level := []int{}
        size := len(queue)

        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]
            level = append(level, node.Val)

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        result = append(result, level)
    }
    return result
}
```

### 3.3 二叉树的最大深度
**题目**: 计算二叉树的最大深度。

**解法**:
```go
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    return max(maxDepth(root.Left), maxDepth(root.Right)) + 1
}
```

### 3.4 验证二叉搜索树
**题目**: 判断是否为有效的二叉搜索树。

**解法**:
```go
func isValidBST(root *TreeNode) bool {
    var validate func(*TreeNode, *int, *int) bool
    validate = func(node *TreeNode, min, max *int) bool {
        if node == nil {
            return true
        }

        if (min != nil && node.Val <= *min) || (max != nil && node.Val >= *max) {
            return false
        }

        return validate(node.Left, min, &node.Val) && validate(node.Right, &node.Val, max)
    }

    return validate(root, nil, nil)
}
```

### 3.5 二叉树的最近公共祖先
**题目**: 找到两个节点的最近公共祖先。

**解法**:
```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }

    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)

    if left != nil && right != nil {
        return root
    }
    if left != nil {
        return left
    }
    return right
}
```

### 3.6 二叉树的右视图
**题目**: 返回从右侧看二叉树能看到的节点值。

**解法**:
```go
func rightSideView(root *TreeNode) []int {
    if root == nil {
        return []int{}
    }

    result := []int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        size := len(queue)
        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]

            if i == size-1 {
                result = append(result, node.Val)
            }

            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
    }
    return result
}
```

### 3.7 路径总和
**题目**: 判断是否存在根到叶子节点路径和等于目标值。

**解法**:
```go
func hasPathSum(root *TreeNode, targetSum int) bool {
    if root == nil {
        return false
    }

    if root.Left == nil && root.Right == nil {
        return root.Val == targetSum
    }

    return hasPathSum(root.Left, targetSum-root.Val) ||
           hasPathSum(root.Right, targetSum-root.Val)
}
```

### 3.8 二叉树展开为链表
**题目**: 将二叉树展开为单链表（前序遍历顺序）。

**解法**:
```go
func flatten(root *TreeNode) {
    if root == nil {
        return
    }

    flatten(root.Left)
    flatten(root.Right)

    left := root.Left
    right := root.Right

    root.Left = nil
    root.Right = left

    curr := root
    for curr.Right != nil {
        curr = curr.Right
    }
    curr.Right = right
}
```

### 3.9 从前序和中序构造二叉树
**题目**: 根据前序和中序遍历结果构造二叉树。

**解法**:
```go
func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder) == 0 {
        return nil
    }

    root := &TreeNode{Val: preorder[0]}
    idx := 0
    for i, v := range inorder {
        if v == preorder[0] {
            idx = i
            break
        }
    }

    root.Left = buildTree(preorder[1:idx+1], inorder[:idx])
    root.Right = buildTree(preorder[idx+1:], inorder[idx+1:])

    return root
}
```

### 3.10 二叉树的序列化和反序列化
**题目**: 实现二叉树的序列化和反序列化。

**解法**:
```go
type Codec struct{}

func (c *Codec) serialize(root *TreeNode) string {
    if root == nil {
        return "null"
    }
    return strconv.Itoa(root.Val) + "," +
           c.serialize(root.Left) + "," +
           c.serialize(root.Right)
}

func (c *Codec) deserialize(data string) *TreeNode {
    nodes := strings.Split(data, ",")
    idx := 0

    var build func() *TreeNode
    build = func() *TreeNode {
        if idx >= len(nodes) || nodes[idx] == "null" {
            idx++
            return nil
        }

        val, _ := strconv.Atoi(nodes[idx])
        idx++
        node := &TreeNode{Val: val}
        node.Left = build()
        node.Right = build()
        return node
    }

    return build()
}
```

## 四、排序和查找算法

### 4.1 快速排序
**题目**: 实现快速排序算法。

**解法**:
```go
func quickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }

    var partition func([]int, int, int) int
    partition = func(arr []int, low, high int) int {
        pivot := arr[high]
        i := low - 1

        for j := low; j < high; j++ {
            if arr[j] < pivot {
                i++
                arr[i], arr[j] = arr[j], arr[i]
            }
        }
        arr[i+1], arr[high] = arr[high], arr[i+1]
        return i + 1
    }

    var sort func([]int, int, int)
    sort = func(arr []int, low, high int) {
        if low < high {
            pi := partition(arr, low, high)
            sort(arr, low, pi-1)
            sort(arr, pi+1, high)
        }
    }

    sort(arr, 0, len(arr)-1)
    return arr
}
```

### 4.2 归并排序
**题目**: 实现归并排序算法。

**解法**:
```go
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }

    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])

    return merge(left, right)
}

func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0

    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }

    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}
```

### 4.3 堆排序
**题目**: 实现堆排序算法。

**解法**:
```go
func heapSort(arr []int) []int {
    n := len(arr)

    heapify := func(arr []int, n, i int) {
        largest := i
        left := 2*i + 1
        right := 2*i + 2

        if left < n && arr[left] > arr[largest] {
            largest = left
        }
        if right < n && arr[right] > arr[largest] {
            largest = right
        }

        if largest != i {
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest)
        }
    }

    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }

    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    }

    return arr
}
```

### 4.4 二分查找
**题目**: 在有序数组中查找目标值。

**解法**:
```go
func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1

    for left <= right {
        mid := left + (right-left)/2

        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

### 4.5 搜索旋转排序数组
**题目**: 在旋转后的有序数组中查找目标值。

**解法**:
```go
func search(nums []int, target int) int {
    left, right := 0, len(nums)-1

    for left <= right {
        mid := left + (right-left)/2

        if nums[mid] == target {
            return mid
        }

        if nums[left] <= nums[mid] {
            if nums[left] <= target && target < nums[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        } else {
            if nums[mid] < target && target <= nums[right] {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
    }
    return -1
}
```

### 4.6 寻找峰值
**题目**: 找到数组中的峰值元素。

**解法**:
```go
func findPeakElement(nums []int) int {
    left, right := 0, len(nums)-1

    for left < right {
        mid := left + (right-left)/2

        if nums[mid] > nums[mid+1] {
            right = mid
        } else {
            left = mid + 1
        }
    }
    return left
}
```

### 4.7 第K大元素
**题目**: 找到数组中第k大的元素。

**解法**:
```go
func findKthLargest(nums []int, k int) int {
    var partition func([]int, int, int) int
    partition = func(arr []int, low, high int) int {
        pivot := arr[high]
        i := low

        for j := low; j < high; j++ {
            if arr[j] > pivot {
                arr[i], arr[j] = arr[j], arr[i]
                i++
            }
        }
        arr[i], arr[high] = arr[high], arr[i]
        return i
    }

    var quickSelect func([]int, int, int, int) int
    quickSelect = func(arr []int, low, high, k int) int {
        if low == high {
            return arr[low]
        }

        pi := partition(arr, low, high)

        if k == pi {
            return arr[k]
        } else if k < pi {
            return quickSelect(arr, low, pi-1, k)
        } else {
            return quickSelect(arr, pi+1, high, k)
        }
    }

    return quickSelect(nums, 0, len(nums)-1, k-1)
}
```

### 4.8 数组中的第K个最大元素（堆实现）
**题目**: 使用最小堆找第k大元素。

**解法**:
```go
import "container/heap"

type MinHeap []int

func (h MinHeap) Len() int           { return len(h) }
func (h MinHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *MinHeap) Push(x interface{}) {
    *h = append(*h, x.(int))
}
func (h *MinHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func findKthLargestHeap(nums []int, k int) int {
    h := &MinHeap{}
    heap.Init(h)

    for _, num := range nums {
        heap.Push(h, num)
        if h.Len() > k {
            heap.Pop(h)
        }
    }

    return (*h)[0]
}
```

### 4.9 前K个高频元素
**题目**: 找出数组中出现频率前k高的元素。

**解法**:
```go
func topKFrequent(nums []int, k int) []int {
    freq := make(map[int]int)
    for _, num := range nums {
        freq[num]++
    }

    type pair struct {
        num   int
        count int
    }

    h := &PairHeap{}
    heap.Init(h)

    for num, count := range freq {
        heap.Push(h, pair{num, count})
        if h.Len() > k {
            heap.Pop(h)
        }
    }

    result := make([]int, k)
    for i := k - 1; i >= 0; i-- {
        result[i] = heap.Pop(h).(pair).num
    }
    return result
}

type PairHeap []pair

func (h PairHeap) Len() int           { return len(h) }
func (h PairHeap) Less(i, j int) bool { return h[i].count < h[j].count }
func (h PairHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *PairHeap) Push(x interface{}) {
    *h = append(*h, x.(pair))
}
func (h *PairHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}
```

### 4.10 寻找两个正序数组的中位数
**题目**: 找到两个有序数组的中位数。

**解法**:
```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    if len(nums1) > len(nums2) {
        nums1, nums2 = nums2, nums1
    }

    m, n := len(nums1), len(nums2)
    left, right := 0, m

    for left <= right {
        i := (left + right) / 2
        j := (m+n+1)/2 - i

        maxLeft1 := math.MinInt32
        if i > 0 {
            maxLeft1 = nums1[i-1]
        }

        minRight1 := math.MaxInt32
        if i < m {
            minRight1 = nums1[i]
        }

        maxLeft2 := math.MinInt32
        if j > 0 {
            maxLeft2 = nums2[j-1]
        }

        minRight2 := math.MaxInt32
        if j < n {
            minRight2 = nums2[j]
        }

        if maxLeft1 <= minRight2 && maxLeft2 <= minRight1 {
            if (m+n)%2 == 0 {
                return float64(max(maxLeft1, maxLeft2)+min(minRight1, minRight2)) / 2.0
            }
            return float64(max(maxLeft1, maxLeft2))
        } else if maxLeft1 > minRight2 {
            right = i - 1
        } else {
            left = i + 1
        }
    }
    return 0.0
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

## 五、动态规划算法

### 5.1 爬楼梯
**题目**: 爬n阶楼梯，每次可以爬1或2阶，有多少种方法。

**解法**:
```go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }

    dp := make([]int, n+1)
    dp[1], dp[2] = 1, 2

    for i := 3; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
}
```

### 5.2 打家劫舍
**题目**: 不能偷相邻的房子，求最大金额。

**解法**:
```go
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }

    dp := make([]int, len(nums))
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])

    for i := 2; i < len(nums); i++ {
        dp[i] = max(dp[i-1], dp[i-2]+nums[i])
    }
    return dp[len(nums)-1]
}
```

### 5.3 最长递增子序列
**题目**: 找出数组中最长递增子序列的长度。

**解法**:
```go
func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    dp := make([]int, len(nums))
    for i := range dp {
        dp[i] = 1
    }

    maxLen := 1
    for i := 1; i < len(nums); i++ {
        for j := 0; j < i; j++ {
            if nums[i] > nums[j] {
                dp[i] = max(dp[i], dp[j]+1)
            }
        }
        maxLen = max(maxLen, dp[i])
    }
    return maxLen
}
```

### 5.4 最长公共子序列
**题目**: 找出两个字符串的最长公共子序列长度。

**解法**:
```go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
}
```

### 5.5 编辑距离
**题目**: 计算将word1转换为word2的最少操作数。

**解法**:
```go
func minDistance(word1 string, word2 string) int {
    m, n := len(word1), len(word2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 0; i <= m; i++ {
        dp[i][0] = i
    }
    for j := 0; j <= n; j++ {
        dp[0][j] = j
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if word1[i-1] == word2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1
            }
        }
    }
    return dp[m][n]
}
```

### 5.6 零钱兑换
**题目**: 给定不同面额的硬币和总金额，计算凑成总金额所需的最少硬币数。

**解法**:
```go
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)
    for i := 1; i <= amount; i++ {
        dp[i] = amount + 1
    }

    for i := 1; i <= amount; i++ {
        for _, coin := range coins {
            if coin <= i {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }

    if dp[amount] > amount {
        return -1
    }
    return dp[amount]
}
```

### 5.7 背包问题（0-1背包）
**题目**: 给定物品重量和价值，背包容量，求最大价值。

**解法**:
```go
func knapsack(weights []int, values []int, capacity int) int {
    n := len(weights)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }

    for i := 1; i <= n; i++ {
        for w := 1; w <= capacity; w++ {
            if weights[i-1] <= w {
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]]+values[i-1])
            } else {
                dp[i][w] = dp[i-1][w]
            }
        }
    }
    return dp[n][capacity]
}
```

### 5.8 最小路径和
**题目**: 从网格左上角到右下角的最小路径和。

**解法**:
```go
func minPathSum(grid [][]int) int {
    if len(grid) == 0 || len(grid[0]) == 0 {
        return 0
    }

    m, n := len(grid), len(grid[0])
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    dp[0][0] = grid[0][0]

    for i := 1; i < m; i++ {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for j := 1; j < n; j++ {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}
```

### 5.9 不同路径
**题目**: 从网格左上角到右下角有多少条不同路径。

**解法**:
```go
func uniquePaths(m int, n int) int {
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
        dp[i][0] = 1
    }
    for j := 0; j < n; j++ {
        dp[0][j] = 1
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
}
```

### 5.10 正则表达式匹配
**题目**: 实现支持'.'和'*'的正则表达式匹配。

**解法**:
```go
func isMatch(s string, p string) bool {
    m, n := len(s), len(p)
    dp := make([][]bool, m+1)
    for i := range dp {
        dp[i] = make([]bool, n+1)
    }

    dp[0][0] = true

    for j := 2; j <= n; j++ {
        if p[j-1] == '*' {
            dp[0][j] = dp[0][j-2]
        }
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if p[j-1] == '*' {
                dp[i][j] = dp[i][j-2]
                if p[j-2] == s[i-1] || p[j-2] == '.' {
                    dp[i][j] = dp[i][j] || dp[i-1][j]
                }
            } else if p[j-1] == '.' || p[j-1] == s[i-1] {
                dp[i][j] = dp[i-1][j-1]
            }
        }
    }
    return dp[m][n]
}
```

### 5.11 股票买卖最佳时机
**题目**: 只能买卖一次，求最大利润。

**解法**:
```go
func maxProfit(prices []int) int {
    if len(prices) == 0 {
        return 0
    }

    minPrice := prices[0]
    maxProfit := 0

    for i := 1; i < len(prices); i++ {
        if prices[i] < minPrice {
            minPrice = prices[i]
        } else if prices[i]-minPrice > maxProfit {
            maxProfit = prices[i] - minPrice
        }
    }
    return maxProfit
}
```

### 5.12 股票买卖最佳时机II
**题目**: 可以多次买卖，求最大利润。

**解法**:
```go
func maxProfitII(prices []int) int {
    profit := 0
    for i := 1; i < len(prices); i++ {
        if prices[i] > prices[i-1] {
            profit += prices[i] - prices[i-1]
        }
    }
    return profit
}
```

### 5.13 分割等和子集
**题目**: 判断数组能否分割成两个和相等的子集。

**解法**:
```go
func canPartition(nums []int) bool {
    sum := 0
    for _, num := range nums {
        sum += num
    }

    if sum%2 != 0 {
        return false
    }

    target := sum / 2
    dp := make([]bool, target+1)
    dp[0] = true

    for _, num := range nums {
        for j := target; j >= num; j-- {
            dp[j] = dp[j] || dp[j-num]
        }
    }
    return dp[target]
}
```

### 5.14 单词拆分
**题目**: 判断字符串能否拆分成字典中的单词。

**解法**:
```go
func wordBreak(s string, wordDict []string) bool {
    wordSet := make(map[string]bool)
    for _, word := range wordDict {
        wordSet[word] = true
    }

    dp := make([]bool, len(s)+1)
    dp[0] = true

    for i := 1; i <= len(s); i++ {
        for j := 0; j < i; j++ {
            if dp[j] && wordSet[s[j:i]] {
                dp[i] = true
                break
            }
        }
    }
    return dp[len(s)]
}
```

### 5.15 最长回文子序列
**题目**: 找出字符串中最长回文子序列的长度。

**解法**:
```go
func longestPalindromeSubseq(s string) int {
    n := len(s)
    dp := make([][]int, n)
    for i := range dp {
        dp[i] = make([]int, n)
        dp[i][i] = 1
    }

    for length := 2; length <= n; length++ {
        for i := 0; i <= n-length; i++ {
            j := i + length - 1
            if s[i] == s[j] {
                dp[i][j] = dp[i+1][j-1] + 2
            } else {
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
            }
        }
    }
    return dp[0][n-1]
}
```

## 六、图算法

### 6.1 岛屿数量
**题目**: 计算二维网格中岛屿的数量。

**解法**:
```go
func numIslands(grid [][]byte) int {
    if len(grid) == 0 {
        return 0
    }

    count := 0
    var dfs func(int, int)
    dfs = func(i, j int) {
        if i < 0 || i >= len(grid) || j < 0 || j >= len(grid[0]) || grid[i][j] == '0' {
            return
        }
        grid[i][j] = '0'
        dfs(i+1, j)
        dfs(i-1, j)
        dfs(i, j+1)
        dfs(i, j-1)
    }

    for i := 0; i < len(grid); i++ {
        for j := 0; j < len(grid[0]); j++ {
            if grid[i][j] == '1' {
                count++
                dfs(i, j)
            }
        }
    }
    return count
}
```

### 6.2 课程表（拓扑排序）
**题目**: 判断能否完成所有课程（检测有向图是否有环）。

**解法**:
```go
func canFinish(numCourses int, prerequisites [][]int) bool {
    graph := make([][]int, numCourses)
    inDegree := make([]int, numCourses)

    for _, pre := range prerequisites {
        graph[pre[1]] = append(graph[pre[1]], pre[0])
        inDegree[pre[0]]++
    }

    queue := []int{}
    for i := 0; i < numCourses; i++ {
        if inDegree[i] == 0 {
            queue = append(queue, i)
        }
    }

    count := 0
    for len(queue) > 0 {
        course := queue[0]
        queue = queue[1:]
        count++

        for _, next := range graph[course] {
            inDegree[next]--
            if inDegree[next] == 0 {
                queue = append(queue, next)
            }
        }
    }

    return count == numCourses
}
```

### 6.3 克隆图
**题目**: 深拷贝无向图。

**解法**:
```go
type Node struct {
    Val       int
    Neighbors []*Node
}

func cloneGraph(node *Node) *Node {
    if node == nil {
        return nil
    }

    visited := make(map[*Node]*Node)

    var clone func(*Node) *Node
    clone = func(n *Node) *Node {
        if n == nil {
            return nil
        }

        if cloned, ok := visited[n]; ok {
            return cloned
        }

        newNode := &Node{Val: n.Val}
        visited[n] = newNode

        for _, neighbor := range n.Neighbors {
            newNode.Neighbors = append(newNode.Neighbors, clone(neighbor))
        }

        return newNode
    }

    return clone(node)
}
```

### 6.4 最短路径（Dijkstra算法）
**题目**: 计算图中从起点到终点的最短路径。

**解法**:
```go
import "container/heap"

type Edge struct {
    to   int
    cost int
}

type Item struct {
    node int
    dist int
}

type PriorityQueue []*Item

func (pq PriorityQueue) Len() int           { return len(pq) }
func (pq PriorityQueue) Less(i, j int) bool { return pq[i].dist < pq[j].dist }
func (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }
func (pq *PriorityQueue) Push(x interface{}) {
    *pq = append(*pq, x.(*Item))
}
func (pq *PriorityQueue) Pop() interface{} {
    old := *pq
    n := len(old)
    item := old[n-1]
    *pq = old[0 : n-1]
    return item
}

func dijkstra(graph [][]Edge, start, end int) int {
    n := len(graph)
    dist := make([]int, n)
    for i := range dist {
        dist[i] = math.MaxInt32
    }
    dist[start] = 0

    pq := &PriorityQueue{}
    heap.Init(pq)
    heap.Push(pq, &Item{node: start, dist: 0})

    for pq.Len() > 0 {
        item := heap.Pop(pq).(*Item)
        u := item.node

        if u == end {
            return dist[end]
        }

        if item.dist > dist[u] {
            continue
        }

        for _, edge := range graph[u] {
            v := edge.to
            newDist := dist[u] + edge.cost

            if newDist < dist[v] {
                dist[v] = newDist
                heap.Push(pq, &Item{node: v, dist: newDist})
            }
        }
    }

    return dist[end]
}
```

### 6.5 并查集（Union-Find）
**题目**: 实现并查集数据结构。

**解法**:
```go
type UnionFind struct {
    parent []int
    rank   []int
}

func NewUnionFind(n int) *UnionFind {
    uf := &UnionFind{
        parent: make([]int, n),
        rank:   make([]int, n),
    }
    for i := 0; i < n; i++ {
        uf.parent[i] = i
    }
    return uf
}

func (uf *UnionFind) Find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.Find(uf.parent[x])
    }
    return uf.parent[x]
}

func (uf *UnionFind) Union(x, y int) bool {
    rootX := uf.Find(x)
    rootY := uf.Find(y)

    if rootX == rootY {
        return false
    }

    if uf.rank[rootX] < uf.rank[rootY] {
        uf.parent[rootX] = rootY
    } else if uf.rank[rootX] > uf.rank[rootY] {
        uf.parent[rootY] = rootX
    } else {
        uf.parent[rootY] = rootX
        uf.rank[rootX]++
    }
    return true
}
```

## 七、回溯算法

### 7.1 全排列
**题目**: 生成数组的所有排列。

**解法**:
```go
func permute(nums []int) [][]int {
    result := [][]int{}
    used := make([]bool, len(nums))
    current := []int{}

    var backtrack func()
    backtrack = func() {
        if len(current) == len(nums) {
            temp := make([]int, len(current))
            copy(temp, current)
            result = append(result, temp)
            return
        }

        for i := 0; i < len(nums); i++ {
            if used[i] {
                continue
            }
            current = append(current, nums[i])
            used[i] = true
            backtrack()
            current = current[:len(current)-1]
            used[i] = false
        }
    }

    backtrack()
    return result
}
```

### 7.2 组合总和
**题目**: 找出所有和为目标值的数字组合。

**解法**:
```go
func combinationSum(candidates []int, target int) [][]int {
    result := [][]int{}
    current := []int{}

    var backtrack func(int, int)
    backtrack = func(start, remain int) {
        if remain == 0 {
            temp := make([]int, len(current))
            copy(temp, current)
            result = append(result, temp)
            return
        }

        for i := start; i < len(candidates); i++ {
            if candidates[i] > remain {
                continue
            }
            current = append(current, candidates[i])
            backtrack(i, remain-candidates[i])
            current = current[:len(current)-1]
        }
    }

    backtrack(0, target)
    return result
}
```

### 7.3 子集
**题目**: 生成数组的所有子集。

**解法**:
```go
func subsets(nums []int) [][]int {
    result := [][]int{}
    current := []int{}

    var backtrack func(int)
    backtrack = func(start int) {
        temp := make([]int, len(current))
        copy(temp, current)
        result = append(result, temp)

        for i := start; i < len(nums); i++ {
            current = append(current, nums[i])
            backtrack(i + 1)
            current = current[:len(current)-1]
        }
    }

    backtrack(0)
    return result
}
```

### 7.4 N皇后问题
**题目**: 在N×N棋盘上放置N个皇后，使其不互相攻击。

**解法**:
```go
func solveNQueens(n int) [][]string {
    result := [][]string{}
    board := make([][]byte, n)
    for i := range board {
        board[i] = make([]byte, n)
        for j := range board[i] {
            board[i][j] = '.'
        }
    }

    isValid := func(row, col int) bool {
        for i := 0; i < row; i++ {
            if board[i][col] == 'Q' {
                return false
            }
        }

        for i, j := row-1, col-1; i >= 0 && j >= 0; i, j = i-1, j-1 {
            if board[i][j] == 'Q' {
                return false
            }
        }

        for i, j := row-1, col+1; i >= 0 && j < n; i, j = i-1, j+1 {
            if board[i][j] == 'Q' {
                return false
            }
        }

        return true
    }

    var backtrack func(int)
    backtrack = func(row int) {
        if row == n {
            solution := make([]string, n)
            for i := range board {
                solution[i] = string(board[i])
            }
            result = append(result, solution)
            return
        }

        for col := 0; col < n; col++ {
            if !isValid(row, col) {
                continue
            }
            board[row][col] = 'Q'
            backtrack(row + 1)
            board[row][col] = '.'
        }
    }

    backtrack(0)
    return result
}
```

### 7.5 括号生成
**题目**: 生成所有有效的括号组合。

**解法**:
```go
func generateParenthesis(n int) []string {
    result := []string{}

    var backtrack func(string, int, int)
    backtrack = func(current string, open, close int) {
        if len(current) == 2*n {
            result = append(result, current)
            return
        }

        if open < n {
            backtrack(current+"(", open+1, close)
        }
        if close < open {
            backtrack(current+")", open, close+1)
        }
    }

    backtrack("", 0, 0)
    return result
}
```

### 7.6 单词搜索
**题目**: 在二维网格中搜索单词。

**解法**:
```go
func exist(board [][]byte, word string) bool {
    if len(board) == 0 || len(word) == 0 {
        return false
    }

    m, n := len(board), len(board[0])

    var backtrack func(int, int, int) bool
    backtrack = func(i, j, k int) bool {
        if k == len(word) {
            return true
        }

        if i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k] {
            return false
        }

        temp := board[i][j]
        board[i][j] = '#'

        found := backtrack(i+1, j, k+1) ||
            backtrack(i-1, j, k+1) ||
            backtrack(i, j+1, k+1) ||
            backtrack(i, j-1, k+1)

        board[i][j] = temp
        return found
    }

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if backtrack(i, j, 0) {
                return true
            }
        }
    }
    return false
}
```

## 八、其他重要算法

### 8.1 LRU缓存
**题目**: 实现LRU缓存机制。

**解法**:
```go
type LRUCache struct {
    capacity int
    cache    map[int]*Node
    head     *Node
    tail     *Node
}

type Node struct {
    key   int
    value int
    prev  *Node
    next  *Node
}

func Constructor(capacity int) LRUCache {
    lru := LRUCache{
        capacity: capacity,
        cache:    make(map[int]*Node),
        head:     &Node{},
        tail:     &Node{},
    }
    lru.head.next = lru.tail
    lru.tail.prev = lru.head
    return lru
}

func (lru *LRUCache) Get(key int) int {
    if node, ok := lru.cache[key]; ok {
        lru.moveToHead(node)
        return node.value
    }
    return -1
}

func (lru *LRUCache) Put(key int, value int) {
    if node, ok := lru.cache[key]; ok {
        node.value = value
        lru.moveToHead(node)
        return
    }

    node := &Node{key: key, value: value}
    lru.cache[key] = node
    lru.addToHead(node)

    if len(lru.cache) > lru.capacity {
        removed := lru.removeTail()
        delete(lru.cache, removed.key)
    }
}

func (lru *LRUCache) addToHead(node *Node) {
    node.prev = lru.head
    node.next = lru.head.next
    lru.head.next.prev = node
    lru.head.next = node
}

func (lru *LRUCache) removeNode(node *Node) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (lru *LRUCache) moveToHead(node *Node) {
    lru.removeNode(node)
    lru.addToHead(node)
}

func (lru *LRUCache) removeTail() *Node {
    node := lru.tail.prev
    lru.removeNode(node)
    return node
}
```

### 8.2 前缀树（Trie）
**题目**: 实现前缀树数据结构。

**解法**:
```go
type Trie struct {
    children map[rune]*Trie
    isEnd    bool
}

func NewTrie() *Trie {
    return &Trie{
        children: make(map[rune]*Trie),
    }
}

func (t *Trie) Insert(word string) {
    node := t
    for _, ch := range word {
        if _, ok := node.children[ch]; !ok {
            node.children[ch] = NewTrie()
        }
        node = node.children[ch]
    }
    node.isEnd = true
}

func (t *Trie) Search(word string) bool {
    node := t
    for _, ch := range word {
        if _, ok := node.children[ch]; !ok {
            return false
        }
        node = node.children[ch]
    }
    return node.isEnd
}

func (t *Trie) StartsWith(prefix string) bool {
    node := t
    for _, ch := range prefix {
        if _, ok := node.children[ch]; !ok {
            return false
        }
        node = node.children[ch]
    }
    return true
}
```

### 8.3 位运算技巧
**题目**: 常见位运算算法。

**解法**:
```go
// 判断是否为2的幂
func isPowerOfTwo(n int) bool {
    return n > 0 && (n&(n-1)) == 0
}

// 计算二进制中1的个数
func hammingWeight(n uint32) int {
    count := 0
    for n != 0 {
        n &= n - 1
        count++
    }
    return count
}

// 只出现一次的数字
func singleNumber(nums []int) int {
    result := 0
    for _, num := range nums {
        result ^= num
    }
    return result
}

// 颠倒二进制位
func reverseBits(num uint32) uint32 {
    result := uint32(0)
    for i := 0; i < 32; i++ {
        result = (result << 1) | (num & 1)
        num >>= 1
    }
    return result
}
```

### 8.4 摩尔投票算法
**题目**: 找出数组中出现次数超过一半的元素。

**解法**:
```go
func majorityElement(nums []int) int {
    candidate := 0
    count := 0

    for _, num := range nums {
        if count == 0 {
            candidate = num
        }
        if num == candidate {
            count++
        } else {
            count--
        }
    }
    return candidate
}
```

### 8.5 蓄水池采样
**题目**: 从数据流中随机选择k个元素。

**解法**:
```go
import "math/rand"

type Solution struct {
    nums []int
}

func Constructor(nums []int) Solution {
    return Solution{nums: nums}
}

func (s *Solution) Pick(target int) int {
    count := 0
    result := -1

    for i, num := range s.nums {
        if num == target {
            count++
            if rand.Intn(count) == 0 {
                result = i
            }
        }
    }
    return result
}
```

## 九、迅雷特色算法题

### 9.1 P2P下载调度算法
**题目**: 设计P2P文件分片下载调度策略。

**思路**:
- 文件分片管理
- 节点选择策略（最少优先、随机选择）
- 下载速度优化
- 断点续传

### 9.2 限流算法
**题目**: 实现令牌桶或漏桶限流算法。

**解法**:
```go
import "time"

type TokenBucket struct {
    capacity  int
    tokens    int
    rate      int
    lastTime  time.Time
}

func NewTokenBucket(capacity, rate int) *TokenBucket {
    return &TokenBucket{
        capacity: capacity,
        tokens:   capacity,
        rate:     rate,
        lastTime: time.Now(),
    }
}

func (tb *TokenBucket) Allow() bool {
    now := time.Now()
    elapsed := now.Sub(tb.lastTime).Seconds()
    tb.tokens = min(tb.capacity, tb.tokens+int(elapsed*float64(tb.rate)))
    tb.lastTime = now

    if tb.tokens > 0 {
        tb.tokens--
        return true
    }
    return false
}
```

### 9.3 一致性哈希
**题目**: 实现一致性哈希算法。

**解法**:
```go
import (
    "hash/crc32"
    "sort"
)

type ConsistentHash struct {
    circle       map[uint32]string
    sortedHashes []uint32
    replicas     int
}

func NewConsistentHash(replicas int) *ConsistentHash {
    return &ConsistentHash{
        circle:   make(map[uint32]string),
        replicas: replicas,
    }
}

func (ch *ConsistentHash) Add(node string) {
    for i := 0; i < ch.replicas; i++ {
        hash := crc32.ChecksumIEEE([]byte(node + string(rune(i))))
        ch.circle[hash] = node
        ch.sortedHashes = append(ch.sortedHashes, hash)
    }
    sort.Slice(ch.sortedHashes, func(i, j int) bool {
        return ch.sortedHashes[i] < ch.sortedHashes[j]
    })
}

func (ch *ConsistentHash) Get(key string) string {
    if len(ch.circle) == 0 {
        return ""
    }

    hash := crc32.ChecksumIEEE([]byte(key))
    idx := sort.Search(len(ch.sortedHashes), func(i int) bool {
        return ch.sortedHashes[i] >= hash
    })

    if idx == len(ch.sortedHashes) {
        idx = 0
    }

    return ch.circle[ch.sortedHashes[idx]]
}
```

### 9.4 布隆过滤器
**题目**: 实现布隆过滤器。

**解法**:
```go
import "hash/fnv"

type BloomFilter struct {
    bitset []bool
    size   int
    hashes int
}

func NewBloomFilter(size, hashes int) *BloomFilter {
    return &BloomFilter{
        bitset: make([]bool, size),
        size:   size,
        hashes: hashes,
    }
}

func (bf *BloomFilter) hash(data string, seed int) int {
    h := fnv.New32a()
    h.Write([]byte(data + string(rune(seed))))
    return int(h.Sum32()) % bf.size
}

func (bf *BloomFilter) Add(data string) {
    for i := 0; i < bf.hashes; i++ {
        pos := bf.hash(data, i)
        bf.bitset[pos] = true
    }
}

func (bf *BloomFilter) Contains(data string) bool {
    for i := 0; i < bf.hashes; i++ {
        pos := bf.hash(data, i)
        if !bf.bitset[pos] {
            return false
        }
    }
    return true
}
```

## 总结

以上算法题涵盖了：
1. 数组和字符串（10题）
2. 链表（7题）
3. 二叉树（10题）
4. 排序和查找（10题）
5. 动态规划（15题）
6. 图算法（5题）
7. 回溯算法（6题）
8. 其他重要算法（5题）
9. 迅雷特色算法（4题）

共计72道算法题，涵盖了Golang开发岗位常见的算法面试题型。建议按照分类逐个练习，重点掌握时间复杂度和空间复杂度分析。

