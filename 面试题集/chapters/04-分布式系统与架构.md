[toc]

## 四、分布式系统与架构

### 1. 微服务架构

**96. 微服务架构的优缺点？**

**答案：**
**优点：**
1. **独立部署**：服务独立，互不影响
2. **技术异构**：不同服务可用不同技术栈
3. **团队自治**：小团队负责单个服务
4. **可扩展性**：按需扩展单个服务
5. **故障隔离**：单个服务故障不影响全局

**缺点：**
1. **复杂度高**：分布式系统复杂
2. **运维成本**：需要完善的DevOps
3. **数据一致性**：分布式事务难处理
4. **网络延迟**：服务间调用增加延迟
5. **测试困难**：集成测试复杂

**适用场景：**
- 大型复杂系统
- 团队规模大
- 需要快速迭代
- 高可用要求

**不适用场景：**
- 小型项目
- 团队规模小
- 业务简单

**97. 如何进行服务拆分？拆分的原则是什么？**

**答案：**
**拆分原则：**
1. **单一职责**：一个服务只做一件事
2. **高内聚低耦合**：服务内部紧密，服务间松散
3. **业务边界清晰**：按业务领域拆分
4. **数据独立**：每个服务独立数据库
5. **可独立部署**：不依赖其他服务

**拆分维度：**
1. **按业务功能**：用户服务、订单服务、商品服务
2. **按技术层次**：网关层、业务层、数据层
3. **按数据特征**：读服务、写服务
4. **按访问频率**：热点服务独立

**拆分步骤：**
```
1. 识别业务边界（DDD领域驱动）
2. 分析依赖关系
3. 定义服务接口
4. 数据库拆分
5. 逐步迁移
```

**示例：**
```
电商系统拆分：
├─ 用户服务（注册、登录、个人信息）
├─ 商品服务（商品管理、库存）
├─ 订单服务（下单、支付、物流）
├─ 营销服务（优惠券、活动）
└─ 搜索服务（商品搜索、推荐）
```

**注意事项：**
- 避免过度拆分
- 考虑团队能力
- 渐进式拆分

**98. 服务发现的实现方式？Etcd和Consul的区别？**

**答案：**
**服务发现方式：**
1. **客户端发现**：
   - 客户端查询注册中心
   - 客户端负载均衡
   - 如：Eureka

2. **服务端发现**：
   - 客户端请求负载均衡器
   - 负载均衡器查询注册中心
   - 如：Nginx + Consul

**Etcd vs Consul：**
| 特性 | Etcd | Consul |
|------|------|--------|
| **一致性算法** | Raft | Raft |
| **健康检查** | 需自己实现 | 内置 |
| **服务发现** | 需自己实现 | 内置 |
| **KV存储** | 支持 | 支持 |
| **多数据中心** | 不支持 | 支持 |
| **UI界面** | 无 | 有 |
| **使用场景** | K8s配置存储 | 服务发现 |

**Etcd示例：**
```go
// 注册服务
client.Put(ctx, "/services/user/node1", "192.168.1.1:8080")

// 发现服务
resp, _ := client.Get(ctx, "/services/user", clientv3.WithPrefix())
for _, kv := range resp.Kvs {
    fmt.Println(string(kv.Value))
}

// 监听变化
watchChan := client.Watch(ctx, "/services/user", clientv3.WithPrefix())
```

**Consul示例：**
```go
// 注册服务
registration := &api.AgentServiceRegistration{
    ID:      "user-service-1",
    Name:    "user-service",
    Address: "192.168.1.1",
    Port:    8080,
    Check: &api.AgentServiceCheck{
        HTTP:     "http://192.168.1.1:8080/health",
        Interval: "10s",
    },
}
client.Agent().ServiceRegister(registration)

// 发现服务
services, _ := client.Health().Service("user-service", "", true, nil)
```

**99. 负载均衡的算法有哪些？各自的适用场景？**

**答案：**
**常见算法：**

1. **轮询（Round Robin）**：
   - 依次分配请求
   - 适合服务器性能相同

2. **加权轮询（Weighted Round Robin）**：
   - 按权重分配
   - 适合服务器性能不同

3. **随机（Random）**：
   - 随机选择服务器
   - 简单，适合服务器性能相同

4. **最少连接（Least Connections）**：
   - 选择连接数最少的服务器
   - 适合长连接场景

5. **一致性哈希（Consistent Hash）**：
   - 根据请求特征哈希
   - 适合缓存场景，减少数据迁移

6. **IP哈希（IP Hash）**：
   - 根据客户端IP哈希
   - 保证同一客户端请求同一服务器

**实现示例：**
```go
// 轮询
type RoundRobin struct {
    servers []string
    index   int
    mu      sync.Mutex
}

func (r *RoundRobin) Next() string {
    r.mu.Lock()
    defer r.mu.Unlock()
    server := r.servers[r.index]
    r.index = (r.index + 1) % len(r.servers)
    return server
}

// 加权轮询
type WeightedRoundRobin struct {
    servers []Server
    index   int
}

type Server struct {
    Addr   string
    Weight int
}

// 一致性哈希
type ConsistentHash struct {
    ring     map[uint32]string
    sortKeys []uint32
}

func (c *ConsistentHash) Get(key string) string {
    hash := c.hashKey(key)
    idx := sort.Search(len(c.sortKeys), func(i int) bool {
        return c.sortKeys[i] >= hash
    })
    if idx == len(c.sortKeys) {
        idx = 0
    }
    return c.ring[c.sortKeys[idx]]
}
```

**100. 如何实现服务熔断和降级？**

**答案：**
**熔断（Circuit Breaker）：**
防止故障扩散，快速失败。

**三种状态：**
```
关闭（Closed）→ 打开（Open）→ 半开（Half-Open）→ 关闭
```

**状态转换：**
1. **Closed**：正常请求，统计失败率
2. **Open**：失败率超过阈值，拒绝请求
3. **Half-Open**：一段时间后，尝试部分请求
4. **Closed**：请求成功，恢复正常

**实现示例：**
```go
type CircuitBreaker struct {
    maxFailures  int
    timeout      time.Duration
    failures     int
    lastFailTime time.Time
    state        State
    mu           sync.Mutex
}

func (cb *CircuitBreaker) Call(fn func() error) error {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    switch cb.state {
    case Open:
        if time.Since(cb.lastFailTime) > cb.timeout {
            cb.state = HalfOpen
        } else {
            return errors.New("circuit breaker is open")
        }
    }

    err := fn()
    if err != nil {
        cb.failures++
        cb.lastFailTime = time.Now()
        if cb.failures >= cb.maxFailures {
            cb.state = Open
        }
        return err
    }

    cb.failures = 0
    cb.state = Closed
    return nil
}
```

**降级（Degradation）：**
服务不可用时，返回默认值或简化服务。

**降级策略：**
1. **返回默认值**
2. **返回缓存数据**
3. **简化服务**
4. **拒绝服务**

**示例：**
```go
func GetUserInfo(userID string) (*User, error) {
    // 尝试调用服务
    user, err := userService.Get(userID)
    if err != nil {
        // 降级：返回缓存
        if cached := cache.Get(userID); cached != nil {
            return cached, nil
        }
        // 降级：返回默认值
        return &User{ID: userID, Name: "Unknown"}, nil
    }
    return user, nil
}
```

**Hystrix示例：**
```go
hystrix.ConfigureCommand("get_user", hystrix.CommandConfig{
    Timeout:               1000,
    MaxConcurrentRequests: 100,
    ErrorPercentThreshold: 50,
})

err := hystrix.Do("get_user", func() error {
    return userService.Get(userID)
}, func(err error) error {
    // 降级逻辑
    return cache.Get(userID)
})
```
**101. 限流的算法有哪些？令牌桶和漏桶的区别？**

**答案：**
**1. 固定窗口计数器：**
```go
var counter int
var lastTime time.Time

func Allow() bool {
    now := time.Now()
    if now.Sub(lastTime) >= time.Second {
        counter = 0
        lastTime = now
    }
    counter++
    return counter <= 100
}
```

**2. 滑动窗口：**
- 更平滑，避免突刺
- 使用Redis ZSet实现（见第91题）

**3. 漏桶（Leaky Bucket）：**
- 固定速率流出
- 请求超过容量则丢弃
- 平滑流量

**4. 令牌桶（Token Bucket）：**
- 固定速率生成令牌
- 有令牌才能通过
- 允许突发流量

**令牌桶 vs 漏桶：**
| 特性 | 令牌桶 | 漏桶 |
|------|--------|------|
| 流量 | 允许突发 | 平滑流出 |
| 实现 | 复杂 | 简单 |
| 应用 | 限制平均速率 | 限制峰值速率 |

**令牌桶实现：**
```go
type TokenBucket struct {
    capacity int64
    tokens   int64
    rate     int64
    lastTime time.Time
    mu       sync.Mutex
}

func (tb *TokenBucket) Allow() bool {
    tb.mu.Lock()
    defer tb.mu.Unlock()

    now := time.Now()
    elapsed := now.Sub(tb.lastTime).Seconds()
    tb.tokens = min(tb.capacity, tb.tokens+int64(elapsed*float64(tb.rate)))
    tb.lastTime = now

    if tb.tokens > 0 {
        tb.tokens--
        return true
    }
    return false
}
```

**102. API网关的作用？如何设计API网关？**

**答案：**
**作用：**
1. **路由转发**：请求路由到后端服务
2. **认证鉴权**：统一认证
3. **限流熔断**：保护后端服务
4. **协议转换**：HTTP/gRPC转换
5. **日志监控**：统一日志
6. **缓存**：减少后端压力

**架构设计：**
```
客户端 → API网关 → 后端服务
         ├─ 认证
         ├─ 限流
         ├─ 路由
         ├─ 熔断
         └─ 监控
```

**实现示例：**
```go
type Gateway struct {
    router     *Router
    auth       *Auth
    limiter    *RateLimiter
    breaker    *CircuitBreaker
}

func (g *Gateway) Handle(req *Request) *Response {
    // 1. 认证
    if !g.auth.Verify(req) {
        return Unauthorized()
    }

    // 2. 限流
    if !g.limiter.Allow(req.UserID) {
        return TooManyRequests()
    }

    // 3. 路由
    service := g.router.Route(req.Path)

    // 4. 熔断
    return g.breaker.Call(func() *Response {
        return service.Call(req)
    })
}
```

**常用网关：**
- Kong
- Nginx + Lua
- Traefik
- Spring Cloud Gateway

**103. 如何实现分布式配置中心？**

**答案：**
**核心功能：**
1. 配置存储
2. 配置推送
3. 版本管理
4. 灰度发布
5. 权限控制

**架构设计：**
```
配置中心
├─ 配置存储（MySQL/Etcd）
├─ 配置服务（HTTP/gRPC）
├─ 推送服务（长轮询/WebSocket）
└─ 管理后台
```

**实现方案：**
```go
// 客户端
type ConfigClient struct {
    serverURL string
    cache     map[string]string
    version   int64
}

func (c *ConfigClient) Get(key string) string {
    // 1. 从缓存获取
    if val, ok := c.cache[key]; ok {
        return val
    }

    // 2. 从服务端获取
    val := c.fetchFromServer(key)
    c.cache[key] = val
    return val
}

func (c *ConfigClient) Watch() {
    for {
        // 长轮询
        resp := c.longPoll(c.version)
        if resp.Version > c.version {
            c.updateCache(resp.Data)
            c.version = resp.Version
        }
    }
}
```

**开源方案：**
- Apollo（携程）
- Nacos（阿里）
- Consul
- Etcd

**104. 链路追踪的原理？如何实现？**

**答案：**
**核心概念：**
- **Trace**：一次完整请求
- **Span**：一个操作单元
- **TraceID**：全局唯一ID
- **SpanID**：Span唯一ID

**数据模型：**
```
Trace (TraceID: abc123)
├─ Span1 (SpanID: 1, 服务A)
│  ├─ Span2 (SpanID: 2, ParentID: 1, 服务B)
│  └─ Span3 (SpanID: 3, ParentID: 1, 服务C)
│     └─ Span4 (SpanID: 4, ParentID: 3, 服务D)
```

**实现原理：**
```go
type Span struct {
    TraceID  string
    SpanID   string
    ParentID string
    Service  string
    Start    time.Time
    End      time.Time
    Tags     map[string]string
}

// 服务A
func ServiceA(ctx context.Context) {
    span := StartSpan(ctx, "ServiceA")
    defer span.Finish()

    // 调用服务B
    ctx = InjectSpan(ctx, span)
    ServiceB(ctx)
}

// 服务B
func ServiceB(ctx context.Context) {
    span := StartSpan(ctx, "ServiceB")
    defer span.Finish()

    // 业务逻辑
}
```

**传播方式：**
```
HTTP Header:
X-Trace-ID: abc123
X-Span-ID: 1
X-Parent-ID: 0

gRPC Metadata:
trace-id: abc123
span-id: 1
```

**开源方案：**
- Jaeger
- Zipkin
- SkyWalking

### 2. 分布式理论

**105. CAP理论的含义？如何权衡？**

**答案：**
**CAP定义：**
- **C (Consistency)**：一致性，所有节点同时看到相同数据
- **A (Availability)**：可用性，每个请求都能得到响应
- **P (Partition Tolerance)**：分区容错性，网络分区时系统仍能工作

**核心结论：**
最多同时满足两个，P是必须的，所以只能在CP和AP中选择。

**权衡：**
| 场景 | 选择 | 示例 |
|------|------|------|
| 金融系统 | CP | 银行转账 |
| 社交网络 | AP | 微博、朋友圈 |
| 注册中心 | CP | Zookeeper, Etcd |
| 缓存系统 | AP | Redis Cluster |

**实践：**
```
CP系统（Etcd）：
- 网络分区时，少数派不可用
- 保证数据一致性

AP系统（Cassandra）：
- 网络分区时，所有节点可用
- 最终一致性
```

**106. BASE理论是什么？**

**答案：**
**BASE定义：**
- **BA (Basically Available)**：基本可用
- **S (Soft State)**：软状态，允许中间状态
- **E (Eventually Consistent)**：最终一致性

**与ACID对比：**
| 特性 | ACID | BASE |
|------|------|------|
| 一致性 | 强一致 | 最终一致 |
| 可用性 | 较低 | 高 |
| 性能 | 较低 | 高 |
| 适用 | 单机 | 分布式 |

**应用场景：**
- 订单系统：下单后异步扣库存
- 积分系统：延迟更新积分
- 消息系统：消息最终送达

**107. 分布式事务的解决方案？2PC、3PC、TCC、Saga的区别？**

**答案：**
**1. 2PC（两阶段提交）：**
```
阶段1：准备（Prepare）
协调者 → 参与者：准备提交
参与者 → 协调者：准备完成

阶段2：提交（Commit）
协调者 → 参与者：提交
参与者 → 协调者：提交完成
```
- **缺点**：同步阻塞、单点故障

**2. 3PC（三阶段提交）：**
```
阶段1：CanCommit
阶段2：PreCommit
阶段3：DoCommit
```
- **改进**：增加超时机制，减少阻塞

**3. TCC（Try-Confirm-Cancel）：**
```go
// Try：预留资源
func Try(orderID string, amount int) error {
    return db.Exec("UPDATE account SET frozen = frozen + ? WHERE id = ?", amount, userID)
}

// Confirm：确认提交
func Confirm(orderID string) error {
    return db.Exec("UPDATE account SET balance = balance - frozen, frozen = 0 WHERE id = ?", userID)
}

// Cancel：取消回滚
func Cancel(orderID string) error {
    return db.Exec("UPDATE account SET frozen = 0 WHERE id = ?", userID)
}
```

**4. Saga：**
```
正向流程：T1 → T2 → T3
补偿流程：C3 → C2 → C1
```

**对比：**
| 方案 | 一致性 | 性能 | 复杂度 |
|------|--------|------|--------|
| 2PC | 强一致 | 低 | 低 |
| TCC | 最终一致 | 高 | 高 |
| Saga | 最终一致 | 高 | 中 |

**108. 最终一致性如何实现？**

**答案：**
**1. 消息队列：**
```go
// 发送方
db.Update(order)
mq.Send(OrderCreatedEvent)

// 接收方
mq.Consume(func(event OrderCreatedEvent) {
    inventory.Deduct(event.ProductID)
})
```

**2. 本地消息表：**
```go
// 事务内写消息表
tx.Begin()
tx.Update(order)
tx.Insert(message_table, event)
tx.Commit()

// 定时任务发送消息
for msg := range message_table {
    mq.Send(msg)
    message_table.Delete(msg.ID)
}
```

**3. 事件溯源：**
- 存储事件而非状态
- 通过重放事件恢复状态

**4. 定时对账：**
- 定期比对数据
- 发现不一致则补偿

**109. 分布式ID生成方案有哪些？Snowflake算法的原理？**

**答案：**
**方案对比：**
| 方案 | 优点 | 缺点 |
|------|------|------|
| UUID | 简单 | 无序、占空间 |
| 数据库自增 | 简单 | 性能差、单点 |
| Redis | 性能好 | 依赖Redis |
| Snowflake | 高性能、有序 | 时钟回拨 |

**Snowflake算法：**
```
64位ID结构：
0 - 41位时间戳 - 10位机器ID - 12位序列号

1位符号位（0）
41位时间戳（毫秒级，可用69年）
10位机器ID（支持1024台机器）
12位序列号（每毫秒4096个ID）
```

**实现：**
```go
type Snowflake struct {
    machineID int64
    sequence  int64
    lastTime  int64
    mu        sync.Mutex
}

func (s *Snowflake) NextID() int64 {
    s.mu.Lock()
    defer s.mu.Unlock()

    now := time.Now().UnixMilli()

    if now < s.lastTime {
        // 时钟回拨
        panic("clock moved backwards")
    }

    if now == s.lastTime {
        s.sequence = (s.sequence + 1) & 4095
        if s.sequence == 0 {
            // 序列号用完，等待下一毫秒
            for now <= s.lastTime {
                now = time.Now().UnixMilli()
            }
        }
    } else {
        s.sequence = 0
    }

    s.lastTime = now

    return (now << 22) | (s.machineID << 12) | s.sequence
}
```

**110. 一致性Hash算法的原理和应用？**

**答案：**
**原理：**
```
1. 将hash值空间组织成环（0 ~ 2^32-1）
2. 将服务器节点hash后放到环上
3. 数据key顺时针找到第一个节点
```

**优势：**
- 节点增减时，只影响相邻节点
- 减少数据迁移

**虚拟节点：**
```go
type ConsistentHash struct {
    ring       map[uint32]string
    sortedKeys []uint32
    replicas   int  // 虚拟节点数
}

func (c *ConsistentHash) Add(node string) {
    for i := 0; i < c.replicas; i++ {
        hash := c.hashKey(node + strconv.Itoa(i))
        c.ring[hash] = node
        c.sortedKeys = append(c.sortedKeys, hash)
    }
    sort.Slice(c.sortedKeys, func(i, j int) bool {
        return c.sortedKeys[i] < c.sortedKeys[j]
    })
}
```

**应用场景：**
- 分布式缓存（Memcached）
- 负载均衡
- 数据分片

**111. Raft共识算法的原理？**

**答案：**
**核心概念：**
- **Leader**：处理所有请求
- **Follower**：被动接收
- **Candidate**：选举中的节点

**选举流程：**
```
1. Follower超时未收到心跳，变为Candidate
2. Candidate发起投票，投自己一票
3. 获得多数票，成为Leader
4. Leader定期发送心跳
```

**日志复制：**
```
1. Leader接收客户端请求
2. Leader追加日志，发送给Follower
3. 多数Follower确认后，Leader提交
4. Leader通知Follower提交
```

**安全性保证：**
- **选举安全性**：一个任期最多一个Leader
- **日志匹配性**：相同索引的日志相同
- **Leader完整性**：Leader包含所有已提交日志

**112. 如何解决分布式系统的时钟同步问题？**

**答案：**
**问题：**
- 不同机器时钟不一致
- 影响分布式事务、日志排序

**解决方案：**

**1. NTP（网络时间协议）：**
```bash
# 配置NTP服务器
ntpdate ntp.aliyun.com
```

**2. 逻辑时钟（Lamport时钟）：**
```go
type LamportClock struct {
    time int64
    mu   sync.Mutex
}

func (lc *LamportClock) Tick() int64 {
    lc.mu.Lock()
    defer lc.mu.Unlock()
    lc.time++
    return lc.time
}

func (lc *LamportClock) Update(recvTime int64) {
    lc.mu.Lock()
    defer lc.mu.Unlock()
    lc.time = max(lc.time, recvTime) + 1
}
```

**3. 向量时钟：**
- 每个节点维护所有节点的时钟
- 可检测并发事件

**4. TrueTime（Google Spanner）：**
- GPS + 原子钟
- 提供时间区间[earliest, latest]

**5. 混合逻辑时钟（HLC）：**
- 结合物理时钟和逻辑时钟
- CockroachDB使用

**最佳实践：**
- 使用NTP同步物理时钟
- 业务逻辑使用逻辑时钟
- 避免依赖绝对时间

### 3. 高可用与容灾

**113. 如何设计一个高可用系统？**

**答案：**
**核心原则：**
1. **消除单点**：所有组件冗余部署
2. **故障隔离**：限流、熔断、降级
3. **快速恢复**：健康检查、自动切换
4. **数据备份**：多副本、异地容灾

**架构设计：**
```
负载均衡（主备）
├─ 应用服务器（多实例）
├─ 数据库（主从/集群）
├─ 缓存（集群）
└─ 消息队列（集群）
```

**关键技术：**
- **负载均衡**：Nginx/LVS主备
- **服务冗余**：至少2个实例
- **数据库**：主从复制、读写分离
- **缓存**：Redis Cluster
- **监控告警**：实时监控、自动告警

**可用性计算：**
```
单机可用性：99.9%（年故障8.76小时）
两台主备：1-(1-0.999)² = 99.9999%
```

**114. 灰度发布的策略？**

**答案：**
**策略类型：**

**1. 按比例灰度：**
```go
func RouteByPercent(userID string, percent int) string {
    hash := hash(userID) % 100
    if hash < percent {
        return "v2"  // 新版本
    }
    return "v1"  // 旧版本
}
```

**2. 按用户灰度：**
```go
// 白名单用户
whiteList := []string{"user1", "user2"}
if contains(whiteList, userID) {
    return "v2"
}
```

**3. 按地区灰度：**
```go
if region == "beijing" {
    return "v2"
}
```

**4. 按特征灰度：**
```go
// VIP用户优先体验
if user.IsVIP {
    return "v2"
}
```

**发布流程：**
```
1. 灰度1%用户 → 观察指标
2. 灰度10%用户 → 观察指标
3. 灰度50%用户 → 观察指标
4. 全量发布
```

**115. 如何实现快速回滚？**

**答案：**
**回滚方案：**

**1. 代码回滚：**
```bash
# Git回滚
git revert <commit>
git push

# 重新部署
kubectl rollout undo deployment/app
```

**2. 流量切换：**
```nginx
# Nginx配置
upstream backend {
    server v1.example.com weight=100;
    server v2.example.com weight=0;  # 回滚：调整权重
}
```

**3. 数据库回滚：**
```sql
-- 使用事务
BEGIN;
-- 执行变更
ROLLBACK;  -- 回滚

-- 或使用备份恢复
```

**4. 配置回滚：**
```go
// 配置中心回滚到上一版本
configCenter.Rollback(version-1)
```

**最佳实践：**
- 保留多个版本
- 蓝绿部署
- 金丝雀发布
- 自动化回滚

**116. 如何进行容量规划？**

**答案：**
**规划步骤：**

**1. 评估当前容量：**
```
- 当前QPS：1000
- 单机QPS：100
- 需要机器：10台
```

**2. 预估业务增长：**
```
- 预计增长：50%
- 峰值系数：3倍
- 需要容量：1000 * 1.5 * 3 = 4500 QPS
```

**3. 计算资源需求：**
```
- 需要机器：4500 / 100 = 45台
- 冗余系数：1.5倍
- 实际需要：45 * 1.5 = 68台
```

**4. 压测验证：**
```bash
# 使用ab/wrk压测
wrk -t10 -c100 -d30s http://api.example.com
```

**监控指标：**
- CPU使用率 < 70%
- 内存使用率 < 80%
- 磁盘使用率 < 80%
- 响应时间 < 100ms

**117. 如何设计降级方案？**

**答案：**
**降级策略：**

**1. 功能降级：**
```go
// 关闭非核心功能
if isOverload() {
    // 关闭推荐功能
    return defaultRecommend()
}
```

**2. 读降级：**
```go
// 返回缓存数据
if dbError {
    return cache.Get(key)
}
```

**3. 写降级：**
```go
// 异步写入
if isOverload() {
    mq.Send(data)  // 改为异步
    return success
}
```

**4. 服务降级：**
```go
// 降级到备用服务
if primaryService.IsDown() {
    return backupService.Call()
}
```

**降级开关：**
```go
type DegradeSwitch struct {
    switches map[string]bool
}

func (d *DegradeSwitch) IsDegrade(feature string) bool {
    return d.switches[feature]
}

// 动态配置
configCenter.Watch("degrade", func(config Config) {
    degradeSwitch.Update(config)
})
```

**118. 双机房和多机房部署的区别？**

**答案：**
**双机房：**
```
机房A（主）     机房B（备）
├─ 应用服务    ├─ 应用服务
├─ 数据库主    ├─ 数据库从
└─ 缓存        └─ 缓存
```
- **优点**：成本低、简单
- **缺点**：主机房故障影响大

**多机房（同城/异地）：**
```
机房A          机房B          机房C
├─ 应用服务    ├─ 应用服务    ├─ 应用服务
├─ 数据库      ├─ 数据库      ├─ 数据库
└─ 缓存        └─ 缓存        └─ 缓存
```
- **优点**：高可用、容灾
- **缺点**：成本高、复杂

**对比：**
| 特性 | 双机房 | 多机房 |
|------|--------|--------|
| 可用性 | 99.9% | 99.99% |
| 成本 | 低 | 高 |
| 复杂度 | 低 | 高 |
| 容灾能力 | 中 | 强 |

**数据同步：**
- **同城多机房**：专线同步，延迟<5ms
- **异地多机房**：异步同步，延迟>50ms

---

