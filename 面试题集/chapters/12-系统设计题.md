[toc]

# 十二、系统设计题

**230. 设计一个短链接系统**

**答案：**
**核心功能：**
1. 长链接转短链接
2. 短链接跳转
3. 统计访问量

**架构设计：**
```
用户 → Nginx → API服务 → Redis(缓存) → MySQL(持久化)
                      ↓
                   ID生成器(Snowflake)
```

**实现方案：**
```go
// 1. 生成短链接
func GenerateShortURL(longURL string) string {
    // 检查是否已存在
    if short := redis.Get("long:" + longURL); short != "" {
        return short
    }

    // 生成ID
    id := snowflake.NextID()

    // Base62编码
    shortCode := base62Encode(id)

    // 存储映射
    redis.Set("short:"+shortCode, longURL, 7*24*time.Hour)
    redis.Set("long:"+longURL, shortCode, 7*24*time.Hour)
    db.Insert(shortCode, longURL)

    return "https://short.url/" + shortCode
}

// 2. 短链接跳转
func Redirect(shortCode string) string {
    // 从缓存获取
    if longURL := redis.Get("short:" + shortCode); longURL != "" {
        // 异步统计
        go incrementCounter(shortCode)
        return longURL
    }

    // 从数据库获取
    longURL := db.Query(shortCode)
    if longURL != "" {
        redis.Set("short:"+shortCode, longURL, 7*24*time.Hour)
        go incrementCounter(shortCode)
        return longURL
    }

    return ""
}

// 3. Base62编码
func base62Encode(num int64) string {
    chars := "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    result := ""

    for num > 0 {
        result = string(chars[num%62]) + result
        num /= 62
    }

    return result
}
```

**数据库设计：**
```sql
CREATE TABLE short_urls (
    id BIGINT PRIMARY KEY,
    short_code VARCHAR(10) UNIQUE,
    long_url VARCHAR(2048),
    visit_count INT DEFAULT 0,
    created_at TIMESTAMP,
    expired_at TIMESTAMP,
    INDEX idx_short_code (short_code)
);
```

**231. 设计一个秒杀系统**

**答案：**
**核心挑战：**
1. 高并发
2. 超卖问题
3. 恶意请求

**架构设计：**
```
用户 → CDN → Nginx → 限流 → API网关 → 秒杀服务 → Redis → MQ → 订单服务
                                                    ↓
                                                 库存服务
```

**关键技术：**
```go
// 1. 预热库存到Redis
func PreloadStock(productID int64, stock int) {
    redis.Set("stock:"+strconv.FormatInt(productID, 10), stock)
}

// 2. 扣减库存（Lua脚本保证原子性）
const decrStockScript = `
local stock = redis.call('get', KEYS[1])
if tonumber(stock) > 0 then
    redis.call('decr', KEYS[1])
    return 1
else
    return 0
end
`

func DecrStock(productID int64) bool {
    result := redis.Eval(decrStockScript, []string{"stock:" + strconv.FormatInt(productID, 10)})
    return result == 1
}

// 3. 秒杀接口
func Seckill(userID, productID int64) error {
    // 限流
    if !rateLimiter.Allow(userID) {
        return errors.New("请求过于频繁")
    }

    // 检查是否已购买
    if redis.SIsMember("bought:"+strconv.FormatInt(productID, 10), userID) {
        return errors.New("已购买")
    }

    // 扣减库存
    if !DecrStock(productID) {
        return errors.New("库存不足")
    }

    // 记录购买
    redis.SAdd("bought:"+strconv.FormatInt(productID, 10), userID)

    // 异步创建订单
    mq.Send(OrderMessage{UserID: userID, ProductID: productID})

    return nil
}

// 4. 令牌桶限流
type TokenBucket struct {
    capacity int64
    tokens   int64
    rate     int64
    lastTime time.Time
    mu       sync.Mutex
}

func (tb *TokenBucket) Allow() bool {
    tb.mu.Lock()
    defer tb.mu.Unlock()

    now := time.Now()
    elapsed := now.Sub(tb.lastTime).Seconds()
    tb.tokens = min(tb.capacity, tb.tokens+int64(elapsed*float64(tb.rate)))
    tb.lastTime = now

    if tb.tokens > 0 {
        tb.tokens--
        return true
    }
    return false
}
```

**防刷策略：**
1. 验证码
2. 用户限流
3. IP限流
4. 黑名单

**232. 设计一个分布式限流系统**

**答案：**
**实现方案：**
```go
// Redis + Lua实现滑动窗口限流
const slidingWindowScript = `
local key = KEYS[1]
local limit = tonumber(ARGV[1])
local window = tonumber(ARGV[2])
local now = tonumber(ARGV[3])

redis.call('zremrangebyscore', key, 0, now - window)
local count = redis.call('zcard', key)

if count < limit then
    redis.call('zadd', key, now, now)
    redis.call('expire', key, window)
    return 1
else
    return 0
end
`

func RateLimit(userID string, limit, window int) bool {
    now := time.Now().Unix()
    key := "ratelimit:" + userID

    result := redis.Eval(slidingWindowScript,
        []string{key},
        limit, window, now,
    )

    return result == 1
}
```

**233. 设计一个消息推送系统**

**答案：**
**架构：**
```
业务系统 → MQ → 推送网关 → 长连接服务集群 → 客户端
                         ↓
                      离线存储
```

**核心功能：**
1. 在线推送（WebSocket）
2. 离线存储
3. 消息去重
4. 推送统计

**234. 设计一个实时排行榜系统**

**答案：**
使用Redis ZSet实现，见第90题详细答案。

**235. 设计一个分布式文件存储系统**

**答案：**
**架构：**
```
客户端 → API网关 → 元数据服务 → MySQL
                 ↓
              存储服务 → 对象存储(S3/OSS)
```

**核心功能：**
1. 文件上传/下载
2. 分片上传
3. 断点续传
4. 秒传（文件去重）

**236. 设计一个搜索引擎**

**答案：**
**架构：**
```
爬虫 → 网页解析 → 倒排索引 → Elasticsearch → 搜索API
```

**核心技术：**
1. 倒排索引
2. TF-IDF
3. PageRank
4. 分词

**237. 设计一个推荐系统**

**答案：**
**推荐算法：**
1. 协同过滤
2. 内容推荐
3. 深度学习

**238. 设计一个IM系统**

**答案：**
**架构：**
```
客户端 → 接入层(WebSocket) → 逻辑层 → 存储层
                           ↓
                        消息队列
```

**核心功能：**
1. 单聊/群聊
2. 消息可靠性
3. 离线消息
4. 消息同步

**239. 设计一个直播系统**

**答案：**
**架构：**
```
主播 → 推流 → 流媒体服务器 → CDN → 观众
                          ↓
                       聊天服务
```

**核心技术：**
1. RTMP推流
2. HLS/FLV拉流
3. CDN分发
4. 弹幕系统
