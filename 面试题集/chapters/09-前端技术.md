# 九、前端技术

## 1. Vue.js

**166. Vue的响应式原理？**

**答案：**
**Vue 2（Object.defineProperty）：**
```javascript
function defineReactive(obj, key, val) {
  const dep = new Dep()

  Object.defineProperty(obj, key, {
    get() {
      if (Dep.target) {
        dep.depend()
      }
      return val
    },
    set(newVal) {
      if (newVal === val) return
      val = newVal
      dep.notify()
    }
  })
}

class Dep {
  constructor() {
    this.subs = []
  }

  depend() {
    if (Dep.target) {
      this.subs.push(Dep.target)
    }
  }

  notify() {
    this.subs.forEach(watcher => watcher.update())
  }
}
```

**Vue 3（Proxy）：**
```javascript
function reactive(target) {
  return new Proxy(target, {
    get(target, key, receiver) {
      track(target, key)
      return Reflect.get(target, key, receiver)
    },
    set(target, key, value, receiver) {
      const result = Reflect.set(target, key, value, receiver)
      trigger(target, key)
      return result
    }
  })
}
```

**167. Vue 2和Vue 3的区别？**

**答案：**
| 特性 | Vue 2 | Vue 3 |
|------|-------|-------|
| 响应式 | Object.defineProperty | Proxy |
| API | Options API | Composition API |
| 性能 | 较慢 | 更快（编译优化） |
| TypeScript | 支持一般 | 完全支持 |
| 体积 | 较大 | 更小（Tree-shaking） |
| Fragment | 不支持 | 支持 |
| Teleport | 不支持 | 支持 |

**Composition API示例：**
```javascript
// Vue 3
import { ref, computed, onMounted } from 'vue'

export default {
  setup() {
    const count = ref(0)
    const double = computed(() => count.value * 2)

    function increment() {
      count.value++
    }

    onMounted(() => {
      console.log('mounted')
    })

    return { count, double, increment }
  }
}
```

**168. Vuex的核心概念？**

**答案：**
```javascript
const store = new Vuex.Store({
  state: {
    count: 0
  },

  getters: {
    doubleCount: state => state.count * 2
  },

  mutations: {
    increment(state) {
      state.count++
    }
  },

  actions: {
    incrementAsync({ commit }) {
      setTimeout(() => {
        commit('increment')
      }, 1000)
    }
  },

  modules: {
    user: userModule
  }
})

// 使用
store.commit('increment')
store.dispatch('incrementAsync')
```

**169. Vue Router的原理？**

**答案：**
**Hash模式：**
```javascript
window.addEventListener('hashchange', () => {
  const hash = window.location.hash.slice(1)
  // 渲染对应组件
})
```

**History模式：**
```javascript
window.addEventListener('popstate', () => {
  const path = window.location.pathname
  // 渲染对应组件
})

// 路由跳转
history.pushState({}, '', '/user')
```

**170. 组件通信的方式有哪些？**

**答案：**
1. **Props / Emit**
2. **$parent / $children**
3. **Provide / Inject**
4. **EventBus**
5. **Vuex**
6. **$attrs / $listeners**

**171. 如何优化Vue应用的性能？**

**答案：**
1. **v-if vs v-show**
2. **computed vs watch**
3. **key的使用**
4. **异步组件**
5. **虚拟滚动**
6. **图片懒加载**
7. **代码分割**

**172. 虚拟DOM的原理？**

**答案：**
```javascript
// 创建虚拟节点
function h(tag, props, children) {
  return { tag, props, children }
}

// diff算法
function patch(oldVNode, newVNode) {
  if (oldVNode.tag !== newVNode.tag) {
    // 替换节点
    return replaceNode(oldVNode, newVNode)
  }

  // 更新属性
  updateProps(oldVNode, newVNode)

  // 更新子节点
  updateChildren(oldVNode.children, newVNode.children)
}
```

**173. diff算法的实现？**

**答案：**
双端比较算法，时间复杂度O(n)。

## 2. 前端工程化

**174. Webpack的核心概念？**

**答案：**
- Entry
- Output
- Loader
- Plugin
- Mode

**175. 如何优化Webpack打包速度？**

**答案：**
1. 缓存
2. 多线程
3. 减少解析范围
4. DllPlugin

**176. Vite相比Webpack有什么优势？**

**答案：**
1. 开发服务器启动快
2. 热更新快
3. 按需编译

**177-178. 代码分割和Tree Shaking**

略（标准答案）

## 3. 移动端开发

**179. Flutter的架构？**

**答案：**
Framework层 → Engine层 → Embedder层

**180. Flutter和React Native的区别？**

**答案：**
| 特性 | Flutter | React Native |
|------|---------|--------------|
| 语言 | Dart | JavaScript |
| 渲染 | 自绘制 | 原生组件 |
| 性能 | 更好 | 较好 |

**181-182. Cocos Creator和跨平台适配**

略（标准答案）
