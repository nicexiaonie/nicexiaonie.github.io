# 七、监控与运维

**144. Prometheus的架构和工作原理？**

**答案：**
**架构组件：**
```
Prometheus Server
├─ Retrieval（数据采集）
├─ TSDB（时序数据库）
├─ HTTP Server（查询接口）
└─ Alertmanager（告警）

数据源：
├─ Exporters（各种exporter）
├─ Pushgateway（短期任务）
└─ Service Discovery（服务发现）
```

**工作原理：**
1. **Pull模式**：主动拉取指标
2. **时序存储**：本地TSDB
3. **PromQL查询**：强大的查询语言
4. **告警规则**：灵活的告警配置

**配置示例：**
```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'node'
    static_configs:
      - targets: ['localhost:9100']

  - job_name: 'app'
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true

alerting:
  alertmanagers:
    - static_configs:
        - targets: ['localhost:9093']

rule_files:
  - 'alerts.yml'
```

**告警规则：**
```yaml
# alerts.yml
groups:
  - name: example
    rules:
      - alert: HighCPU
        expr: node_cpu_usage > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "CPU使用率过高"
          description: "{{ $labels.instance }} CPU使用率 {{ $value }}%"

      - alert: ServiceDown
        expr: up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "服务宕机"
```

**145. 如何设计监控指标？**

**答案：**
**四大黄金指标（Google SRE）：**
1. **延迟（Latency）**：请求响应时间
2. **流量（Traffic）**：QPS、带宽
3. **错误（Errors）**：错误率
4. **饱和度（Saturation）**：资源使用率

**RED方法（微服务）：**
- **Rate**：请求速率
- **Errors**：错误率
- **Duration**：响应时间

**USE方法（资源）：**
- **Utilization**：使用率
- **Saturation**：饱和度
- **Errors**：错误数

**指标设计示例：**
```go
// 业务指标
var (
    // Counter：累计值
    httpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total HTTP requests",
        },
        []string{"method", "endpoint", "status"},
    )

    // Histogram：分布统计
    httpDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name:    "http_duration_seconds",
            Help:    "HTTP request duration",
            Buckets: []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10},
        },
        []string{"method", "endpoint"},
    )

    // Gauge：瞬时值
    activeConnections = prometheus.NewGauge(
        prometheus.GaugeOpts{
            Name: "active_connections",
            Help: "Current active connections",
        },
    )

    // Summary：分位数
    requestSize = prometheus.NewSummary(
        prometheus.SummaryOpts{
            Name:       "request_size_bytes",
            Help:       "Request size in bytes",
            Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
        },
    )
)

// 使用
func handler(w http.ResponseWriter, r *http.Request) {
    start := time.Now()

    // 业务逻辑

    // 记录指标
    httpRequestsTotal.WithLabelValues(r.Method, r.URL.Path, "200").Inc()
    httpDuration.WithLabelValues(r.Method, r.URL.Path).Observe(time.Since(start).Seconds())
    activeConnections.Inc()
    defer activeConnections.Dec()
}
```

**146. Grafana如何使用？**

**答案：**
**核心功能：**
1. 数据可视化
2. 多数据源支持
3. 告警通知
4. 仪表盘分享

**常用面板类型：**
- Graph：折线图
- Stat：单值显示
- Gauge：仪表盘
- Table：表格
- Heatmap：热力图

**PromQL查询示例：**
```promql
# CPU使用率
100 - (avg by (instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)

# 内存使用率
(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100

# QPS
rate(http_requests_total[1m])

# P99延迟
histogram_quantile(0.99, rate(http_duration_seconds_bucket[5m]))

# 错误率
rate(http_requests_total{status=~"5.."}[1m]) / rate(http_requests_total[1m]) * 100
```

**仪表盘JSON配置：**
```json
{
  "dashboard": {
    "title": "应用监控",
    "panels": [
      {
        "title": "QPS",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total[1m])",
            "legendFormat": "{{instance}}"
          }
        ]
      }
    ]
  }
}
```

**147. ELK的架构？Logstash、Elasticsearch、Kibana各自的作用？**

**答案：**
**架构：**
```
数据源 → Filebeat → Logstash → Elasticsearch → Kibana
         (采集)    (处理)      (存储)         (展示)
```

**组件作用：**

**1. Filebeat（轻量级采集）：**
```yaml
# filebeat.yml
filebeat.inputs:
  - type: log
    enabled: true
    paths:
      - /var/log/app/*.log
    fields:
      app: myapp
      env: prod

output.logstash:
  hosts: ["localhost:5044"]
```

**2. Logstash（数据处理）：**
```ruby
# logstash.conf
input {
  beats {
    port => 5044
  }
}

filter {
  grok {
    match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:msg}" }
  }

  date {
    match => ["timestamp", "ISO8601"]
  }

  mutate {
    remove_field => ["message"]
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "app-logs-%{+YYYY.MM.dd}"
  }
}
```

**3. Elasticsearch（存储和搜索）：**
- 分布式搜索引擎
- 倒排索引
- 全文检索

**4. Kibana（可视化）：**
- 日志查询
- 仪表盘
- 告警

**148. 如何设计日志系统？**

**答案：**
**日志级别：**
```go
const (
    DEBUG   // 调试信息
    INFO    // 一般信息
    WARN    // 警告
    ERROR   // 错误
    FATAL   // 致命错误
)
```

**日志格式（结构化）：**
```json
{
  "timestamp": "2025-01-24T10:00:00Z",
  "level": "INFO",
  "service": "user-service",
  "trace_id": "abc123",
  "span_id": "def456",
  "message": "User login success",
  "user_id": "12345",
  "ip": "192.168.1.1"
}
```

**日志实现：**
```go
type Logger struct {
    level     Level
    output    io.Writer
    traceID   string
}

func (l *Logger) Info(msg string, fields ...Field) {
    if l.level > INFO {
        return
    }

    entry := LogEntry{
        Timestamp: time.Now(),
        Level:     "INFO",
        TraceID:   l.traceID,
        Message:   msg,
        Fields:    fields,
    }

    json.NewEncoder(l.output).Encode(entry)
}

// 使用
logger.Info("User login",
    Field{"user_id", userID},
    Field{"ip", ip},
)
```

**日志收集架构：**
```
应用 → 本地文件 → Filebeat → Kafka → Logstash → ES → Kibana
                              ↓
                           备份存储
```

**最佳实践：**
1. 结构化日志
2. 统一格式
3. 包含trace_id
4. 敏感信息脱敏
5. 日志分级
6. 异步写入

**149. 如何实现分布式链路追踪？**

**答案：**
见第104题的详细答案。

**补充OpenTelemetry实现：**
```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

func handler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    tracer := otel.Tracer("my-service")

    // 创建span
    ctx, span := tracer.Start(ctx, "handler")
    defer span.End()

    // 添加属性
    span.SetAttributes(
        attribute.String("user.id", userID),
        attribute.Int("http.status", 200),
    )

    // 调用下游服务
    callDownstream(ctx)
}

func callDownstream(ctx context.Context) {
    tracer := otel.Tracer("my-service")
    ctx, span := tracer.Start(ctx, "call-downstream")
    defer span.End()

    // HTTP请求传递trace信息
    req, _ := http.NewRequestWithContext(ctx, "GET", url, nil)
    otel.GetTextMapPropagator().Inject(ctx, propagation.HeaderCarrier(req.Header))

    resp, err := client.Do(req)
    if err != nil {
        span.RecordError(err)
        span.SetStatus(codes.Error, err.Error())
    }
}
```

**150. 如何进行故障排查？**

**答案：**
**排查流程：**

**1. 确认问题：**
- 现象：响应慢、报错、宕机
- 影响范围：全部用户还是部分
- 开始时间：何时开始

**2. 查看监控：**
```bash
# CPU/内存/磁盘
top
free -h
df -h

# 网络
netstat -antp
ss -s

# 进程
ps aux | grep app
lsof -p <pid>

# 日志
tail -f /var/log/app.log
grep ERROR /var/log/app.log
```

**3. 分析指标：**
- Grafana查看监控曲线
- 对比正常时段
- 找出异常指标

**4. 查看日志：**
```bash
# Kibana查询
level:ERROR AND service:user-service

# 统计错误
grep ERROR app.log | wc -l

# 查看堆栈
grep -A 20 "panic" app.log
```

**5. 链路追踪：**
- Jaeger查看慢请求
- 定位瓶颈环节

**6. 数据库排查：**
```sql
-- 慢查询
SHOW PROCESSLIST;
SHOW FULL PROCESSLIST;

-- 锁等待
SELECT * FROM information_schema.innodb_trx;
SELECT * FROM information_schema.innodb_locks;
```

**7. 应用排查：**
```bash
# Go应用
curl http://localhost:6060/debug/pprof/goroutine
go tool pprof http://localhost:6060/debug/pprof/heap

# Java应用
jstack <pid>
jmap -heap <pid>
```

**151. CI/CD的流程？Jenkins如何使用？**

**答案：**
**CI/CD流程：**
```
代码提交 → 代码检查 → 单元测试 → 构建镜像 → 推送仓库 → 部署测试环境 → 集成测试 → 部署生产环境
```

**Jenkinsfile示例：**
```groovy
pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = 'registry.example.com'
        IMAGE_NAME = 'myapp'
        K8S_NAMESPACE = 'production'
    }

    stages {
        stage('Checkout') {
            steps {
                git branch: 'main', url: 'https://github.com/user/repo.git'
            }
        }

        stage('Test') {
            steps {
                sh 'go test ./...'
            }
        }

        stage('Build') {
            steps {
                sh 'go build -o main .'
            }
        }

        stage('Docker Build') {
            steps {
                script {
                    docker.build("${DOCKER_REGISTRY}/${IMAGE_NAME}:${BUILD_NUMBER}")
                }
            }
        }

        stage('Docker Push') {
            steps {
                script {
                    docker.withRegistry("https://${DOCKER_REGISTRY}", 'docker-credentials') {
                        docker.image("${DOCKER_REGISTRY}/${IMAGE_NAME}:${BUILD_NUMBER}").push()
                        docker.image("${DOCKER_REGISTRY}/${IMAGE_NAME}:${BUILD_NUMBER}").push('latest')
                    }
                }
            }
        }

        stage('Deploy to K8s') {
            steps {
                sh """
                    kubectl set image deployment/myapp \
                        myapp=${DOCKER_REGISTRY}/${IMAGE_NAME}:${BUILD_NUMBER} \
                        -n ${K8S_NAMESPACE}
                    kubectl rollout status deployment/myapp -n ${K8S_NAMESPACE}
                """
            }
        }
    }

    post {
        success {
            dingtalk(
                robot: 'jenkins-bot',
                type: 'MARKDOWN',
                title: '部署成功',
                text: ["### 部署成功\n- 项目: ${IMAGE_NAME}\n- 版本: ${BUILD_NUMBER}"]
            )
        }
        failure {
            dingtalk(
                robot: 'jenkins-bot',
                type: 'MARKDOWN',
                title: '部署失败',
                text: ["### 部署失败\n- 项目: ${IMAGE_NAME}\n- 版本: ${BUILD_NUMBER}"]
            )
        }
    }
}
```

**GitLab CI示例：**
```yaml
# .gitlab-ci.yml
stages:
  - test
  - build
  - deploy

variables:
  DOCKER_REGISTRY: registry.example.com
  IMAGE_NAME: myapp

test:
  stage: test
  script:
    - go test ./...

build:
  stage: build
  script:
    - docker build -t ${DOCKER_REGISTRY}/${IMAGE_NAME}:${CI_COMMIT_SHA} .
    - docker push ${DOCKER_REGISTRY}/${IMAGE_NAME}:${CI_COMMIT_SHA}

deploy:
  stage: deploy
  script:
    - kubectl set image deployment/myapp myapp=${DOCKER_REGISTRY}/${IMAGE_NAME}:${CI_COMMIT_SHA}
  only:
    - main
```

**152. 如何实现自动化测试？**

**答案：**
**测试金字塔：**
```
       /\
      /E2E\      (少量)
     /------\
    /  集成  \    (适量)
   /----------\
  /   单元测试  \  (大量)
 /--------------\
```

**单元测试：**
```go
// user_test.go
func TestCreateUser(t *testing.T) {
    tests := []struct {
        name    string
        input   User
        wantErr bool
    }{
        {
            name:    "valid user",
            input:   User{Name: "John", Age: 30},
            wantErr: false,
        },
        {
            name:    "invalid age",
            input:   User{Name: "John", Age: -1},
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := CreateUser(tt.input)
            if (err != nil) != tt.wantErr {
                t.Errorf("CreateUser() error = %v, wantErr %v", err, tt.wantErr)
            }
        })
    }
}

// Mock测试
func TestGetUser(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    mockDB := mock.NewMockDB(ctrl)
    mockDB.EXPECT().Query("SELECT * FROM users WHERE id = ?", 1).Return(User{ID: 1, Name: "John"}, nil)

    service := NewUserService(mockDB)
    user, err := service.GetUser(1)

    assert.NoError(t, err)
    assert.Equal(t, "John", user.Name)
}
```

**集成测试：**
```go
func TestUserAPI(t *testing.T) {
    // 启动测试服务器
    ts := httptest.NewServer(handler)
    defer ts.Close()

    // 测试创建用户
    resp, err := http.Post(ts.URL+"/users", "application/json",
        strings.NewReader(`{"name":"John","age":30}`))
    assert.NoError(t, err)
    assert.Equal(t, 200, resp.StatusCode)

    // 测试获取用户
    resp, err = http.Get(ts.URL + "/users/1")
    assert.NoError(t, err)
    assert.Equal(t, 200, resp.StatusCode)
}
```

**E2E测试（Selenium）：**
```python
from selenium import webdriver

def test_login():
    driver = webdriver.Chrome()
    driver.get("http://example.com/login")

    # 输入用户名密码
    driver.find_element_by_id("username").send_keys("admin")
    driver.find_element_by_id("password").send_keys("password")
    driver.find_element_by_id("submit").click()

    # 验证登录成功
    assert "Dashboard" in driver.title

    driver.quit()
```

**性能测试：**
```bash
# wrk压测
wrk -t10 -c100 -d30s http://api.example.com

# ab压测
ab -n 10000 -c 100 http://api.example.com/

# JMeter脚本
```

**测试覆盖率：**
```bash
# Go
go test -cover ./...
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out

# 目标：单元测试覆盖率 > 80%
```
