# 八、算法与数据结构

## 1. 文本相似度算法

**153. SimHash算法的原理？如何应用于文本去重？**

**答案：**
**原理：**
将文本转换为固定长度的指纹（64位），相似文本的指纹海明距离小。

**算法步骤：**
```go
func SimHash(text string) uint64 {
    // 1. 分词
    words := tokenize(text)

    // 2. 计算权重向量
    vector := make([]int, 64)
    for _, word := range words {
        hash := hash64(word)
        weight := getWeight(word)

        for i := 0; i < 64; i++ {
            if (hash>>i)&1 == 1 {
                vector[i] += weight
            } else {
                vector[i] -= weight
            }
        }
    }

    // 3. 降维
    var fingerprint uint64
    for i := 0; i < 64; i++ {
        if vector[i] > 0 {
            fingerprint |= 1 << i
        }
    }

    return fingerprint
}

// 计算海明距离
func HammingDistance(a, b uint64) int {
    xor := a ^ b
    count := 0
    for xor != 0 {
        count++
        xor &= xor - 1
    }
    return count
}

// 判断相似
func IsSimilar(a, b uint64, threshold int) bool {
    return HammingDistance(a, b) <= threshold
}
```

**应用于去重：**
```go
type DeduplicateSystem struct {
    fingerprints map[uint64][]string  // 指纹 -> 文档ID列表
    threshold    int                   // 海明距离阈值
}

func (d *DeduplicateSystem) Add(docID, text string) bool {
    fingerprint := SimHash(text)

    // 检查是否重复
    for fp, docs := range d.fingerprints {
        if HammingDistance(fingerprint, fp) <= d.threshold {
            // 发现重复
            return false
        }
    }

    // 添加新文档
    d.fingerprints[fingerprint] = append(d.fingerprints[fingerprint], docID)
    return true
}
```

**优化：分块查找**
```go
// 将64位分成4块，每块16位
func GetBlocks(fingerprint uint64) [4]uint16 {
    return [4]uint16{
        uint16(fingerprint),
        uint16(fingerprint >> 16),
        uint16(fingerprint >> 32),
        uint16(fingerprint >> 48),
    }
}

// 只需检查至少有一块相同的指纹
```

**154. MinHash算法的原理？**

**答案：**
**原理：**
通过多次哈希函数估算Jaccard相似度。

**Jaccard相似度：**
```
J(A, B) = |A ∩ B| / |A ∪ B|
```

**MinHash实现：**
```go
type MinHash struct {
    numHashes int
    signature []uint32
}

func NewMinHash(text string, numHashes int) *MinHash {
    // 1. 分词得到集合
    words := tokenize(text)
    wordSet := make(map[string]bool)
    for _, w := range words {
        wordSet[w] = true
    }

    // 2. 计算签名
    signature := make([]uint32, numHashes)
    for i := 0; i < numHashes; i++ {
        signature[i] = math.MaxUint32

        for word := range wordSet {
            hash := hashWithSeed(word, i)
            if hash < signature[i] {
                signature[i] = hash
            }
        }
    }

    return &MinHash{
        numHashes: numHashes,
        signature: signature,
    }
}

// 估算相似度
func (m *MinHash) Similarity(other *MinHash) float64 {
    if m.numHashes != other.numHashes {
        return 0
    }

    same := 0
    for i := 0; i < m.numHashes; i++ {
        if m.signature[i] == other.signature[i] {
            same++
        }
    }

    return float64(same) / float64(m.numHashes)
}
```

**155. LSH（局部敏感哈希）的原理和应用？**

**答案：**
**原理：**
将相似的项映射到同一个桶，实现快速相似搜索。

**LSH for MinHash：**
```go
type LSH struct {
    bands   int
    rows    int
    buckets []map[string][]string  // 每个band一个哈希表
}

func NewLSH(bands, rows int) *LSH {
    buckets := make([]map[string][]string, bands)
    for i := range buckets {
        buckets[i] = make(map[string][]string)
    }
    return &LSH{bands: bands, rows: rows, buckets: buckets}
}

func (lsh *LSH) Add(docID string, signature []uint32) {
    for band := 0; band < lsh.bands; band++ {
        // 取出该band的rows个值
        start := band * lsh.rows
        end := start + lsh.rows
        bandSig := signature[start:end]

        // 计算band的哈希值
        bandHash := hashSlice(bandSig)

        // 添加到对应的桶
        lsh.buckets[band][bandHash] = append(lsh.buckets[band][bandHash], docID)
    }
}

func (lsh *LSH) Query(signature []uint32) []string {
    candidates := make(map[string]bool)

    for band := 0; band < lsh.bands; band++ {
        start := band * lsh.rows
        end := start + lsh.rows
        bandSig := signature[start:end]
        bandHash := hashSlice(bandSig)

        // 获取候选文档
        for _, docID := range lsh.buckets[band][bandHash] {
            candidates[docID] = true
        }
    }

    result := make([]string, 0, len(candidates))
    for docID := range candidates {
        result = append(result, docID)
    }
    return result
}
```

**参数选择：**
```
bands * rows = numHashes
相似度阈值 t ≈ (1/bands)^(1/rows)

例如：bands=20, rows=5
阈值 t ≈ 0.5
```

**156. 如何优化10亿级数据的相似度检索？**

**答案：**
**架构设计：**
```
SimHash指纹 → 分块索引 → Redis Cluster
MinHash签名 → LSH分桶 → 候选集 → 精确计算
```

**优化策略：**

**1. 分层过滤：**
```go
// 第一层：SimHash快速过滤
func Layer1Filter(text string) []string {
    fingerprint := SimHash(text)
    blocks := GetBlocks(fingerprint)

    candidates := make(map[string]bool)
    for _, block := range blocks {
        // 从Redis查询相同block的文档
        docs := redis.SMembers("block:" + strconv.Itoa(int(block)))
        for _, doc := range docs {
            candidates[doc] = true
        }
    }
    return mapToSlice(candidates)
}

// 第二层：MinHash精确计算
func Layer2Filter(text string, candidates []string) []string {
    mh := NewMinHash(text, 128)

    results := []string{}
    for _, docID := range candidates {
        docMH := getMinHashFromDB(docID)
        if mh.Similarity(docMH) > 0.8 {
            results = append(results, docID)
        }
    }
    return results
}
```

**2. 分布式存储：**
```go
// Redis Cluster分片
func GetShardKey(fingerprint uint64) string {
    return fmt.Sprintf("shard:%d", fingerprint%1024)
}

// 写入
func AddDocument(docID string, fingerprint uint64) {
    shard := GetShardKey(fingerprint)
    redis.SAdd(shard, docID)
}
```

**3. 批量处理：**
```go
// 批量查询
func BatchQuery(texts []string) map[string][]string {
    results := make(map[string][]string)

    // 并发处理
    var wg sync.WaitGroup
    for _, text := range texts {
        wg.Add(1)
        go func(t string) {
            defer wg.Done()
            results[t] = Query(t)
        }(text)
    }
    wg.Wait()

    return results
}
```

**4. 缓存热点：**
```go
var cache = lru.New(10000)

func QueryWithCache(text string) []string {
    key := SimHash(text)
    if val, ok := cache.Get(key); ok {
        return val.([]string)
    }

    result := Query(text)
    cache.Add(key, result)
    return result
}
```

**157. 如何提高召回率和准确率？**

**答案：**
**召回率优化：**

**1. 降低阈值：**
```go
// SimHash海明距离阈值从3提高到5
threshold := 5
```

**2. 多特征融合：**
```go
type MultiFeature struct {
    simhash  uint64
    minhash  []uint32
    keywords []string
}

func IsMatch(a, b MultiFeature) bool {
    // 任一特征匹配即认为相似
    if HammingDistance(a.simhash, b.simhash) <= 5 {
        return true
    }

    mh1 := &MinHash{signature: a.minhash}
    mh2 := &MinHash{signature: b.minhash}
    if mh1.Similarity(mh2) > 0.7 {
        return true
    }

    if KeywordOverlap(a.keywords, b.keywords) > 0.5 {
        return true
    }

    return false
}
```

**3. 分块策略：**
```go
// SimHash分4块，只要1块匹配就召回
func RecallByBlocks(fingerprint uint64) []string {
    blocks := GetBlocks(fingerprint)
    candidates := make(map[string]bool)

    for _, block := range blocks {
        docs := redis.SMembers("block:" + string(block))
        for _, doc := range docs {
            candidates[doc] = true
        }
    }

    return mapToSlice(candidates)
}
```

**准确率优化：**

**1. 二次验证：**
```go
func PrecisionFilter(text string, candidates []string) []string {
    results := []string{}

    for _, docID := range candidates {
        docText := getDocumentText(docID)

        // 计算编辑距离
        if EditDistance(text, docText) < len(text)/10 {
            results = append(results, docID)
        }
    }

    return results
}
```

**2. 机器学习模型：**
```go
// 使用训练好的模型进行二分类
func MLFilter(text1, text2 string) bool {
    features := extractFeatures(text1, text2)
    score := model.Predict(features)
    return score > 0.9
}
```

**3. 人工审核：**
```go
// 边界case人工审核
func NeedManualReview(similarity float64) bool {
    return similarity > 0.7 && similarity < 0.9
}
```

## 2. 常用算法

**158. 常用的排序算法及其时间复杂度？**

**答案：**
| 算法 | 平均 | 最坏 | 最好 | 空间 | 稳定性 |
|------|------|------|------|------|--------|
| 冒泡 | O(n²) | O(n²) | O(n) | O(1) | 稳定 |
| 选择 | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 |
| 插入 | O(n²) | O(n²) | O(n) | O(1) | 稳定 |
| 快排 | O(nlogn) | O(n²) | O(nlogn) | O(logn) | 不稳定 |
| 归并 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | 稳定 |
| 堆排 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | 不稳定 |

**快速排序：**
```go
func quickSort(arr []int, left, right int) {
    if left >= right {
        return
    }

    pivot := partition(arr, left, right)
    quickSort(arr, left, pivot-1)
    quickSort(arr, pivot+1, right)
}

func partition(arr []int, left, right int) int {
    pivot := arr[right]
    i := left - 1

    for j := left; j < right; j++ {
        if arr[j] < pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }

    arr[i+1], arr[right] = arr[right], arr[i+1]
    return i + 1
}
```

**159. 二分查找的变种？**

**答案：**
```go
// 1. 标准二分查找
func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1

    for left <= right {
        mid := left + (right-left)/2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return -1
}

// 2. 查找第一个等于target的位置
func findFirst(arr []int, target int) int {
    left, right := 0, len(arr)-1
    result := -1

    for left <= right {
        mid := left + (right-left)/2
        if arr[mid] == target {
            result = mid
            right = mid - 1  // 继续向左找
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return result
}

// 3. 查找最后一个等于target的位置
func findLast(arr []int, target int) int {
    left, right := 0, len(arr)-1
    result := -1

    for left <= right {
        mid := left + (right-left)/2
        if arr[mid] == target {
            result = mid
            left = mid + 1  // 继续向右找
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }

    return result
}

// 4. 查找第一个大于等于target的位置
func lowerBound(arr []int, target int) int {
    left, right := 0, len(arr)

    for left < right {
        mid := left + (right-left)/2
        if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid
        }
    }

    return left
}
```

**160. 动态规划的思想？**

**答案：**
**核心思想：**
将问题分解为子问题，保存子问题的解，避免重复计算。

**经典问题：**

**1. 斐波那契数列：**
```go
func fib(n int) int {
    if n <= 1 {
        return n
    }

    dp := make([]int, n+1)
    dp[0], dp[1] = 0, 1

    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}

// 空间优化
func fibOptimized(n int) int {
    if n <= 1 {
        return n
    }

    prev, curr := 0, 1
    for i := 2; i <= n; i++ {
        prev, curr = curr, prev+curr
    }

    return curr
}
```

**2. 背包问题：**
```go
func knapsack(weights, values []int, capacity int) int {
    n := len(weights)
    dp := make([][]int, n+1)
    for i := range dp {
        dp[i] = make([]int, capacity+1)
    }

    for i := 1; i <= n; i++ {
        for w := 1; w <= capacity; w++ {
            if weights[i-1] <= w {
                dp[i][w] = max(
                    dp[i-1][w],
                    dp[i-1][w-weights[i-1]]+values[i-1],
                )
            } else {
                dp[i][w] = dp[i-1][w]
            }
        }
    }

    return dp[n][capacity]
}
```

**3. 最长公共子序列：**
```go
func longestCommonSubsequence(text1, text2 string) int {
    m, n := len(text1), len(text2)
    dp := make([][]int, m+1)
    for i := range dp {
        dp[i] = make([]int, n+1)
    }

    for i := 1; i <= m; i++ {
        for j := 1; j <= n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    return dp[m][n]
}
```

**161. 贪心算法的应用场景？**

**答案：**
**特点：**
每步选择当前最优解，不回溯。

**经典问题：**

**1. 活动选择：**
```go
type Activity struct {
    start, end int
}

func maxActivities(activities []Activity) int {
    // 按结束时间排序
    sort.Slice(activities, func(i, j int) bool {
        return activities[i].end < activities[j].end
    })

    count := 1
    lastEnd := activities[0].end

    for i := 1; i < len(activities); i++ {
        if activities[i].start >= lastEnd {
            count++
            lastEnd = activities[i].end
        }
    }

    return count
}
```

**2. 找零钱：**
```go
func coinChange(coins []int, amount int) int {
    sort.Slice(coins, func(i, j int) bool {
        return coins[i] > coins[j]
    })

    count := 0
    for _, coin := range coins {
        if amount >= coin {
            count += amount / coin
            amount %= coin
        }
    }

    if amount > 0 {
        return -1
    }
    return count
}
```

**162. 如何设计LRU缓存？**

**答案：**
```go
type LRUCache struct {
    capacity int
    cache    map[int]*Node
    head     *Node
    tail     *Node
}

type Node struct {
    key, value int
    prev, next *Node
}

func Constructor(capacity int) LRUCache {
    head := &Node{}
    tail := &Node{}
    head.next = tail
    tail.prev = head

    return LRUCache{
        capacity: capacity,
        cache:    make(map[int]*Node),
        head:     head,
        tail:     tail,
    }
}

func (lru *LRUCache) Get(key int) int {
    if node, ok := lru.cache[key]; ok {
        lru.moveToHead(node)
        return node.value
    }
    return -1
}

func (lru *LRUCache) Put(key, value int) {
    if node, ok := lru.cache[key]; ok {
        node.value = value
        lru.moveToHead(node)
        return
    }

    node := &Node{key: key, value: value}
    lru.cache[key] = node
    lru.addToHead(node)

    if len(lru.cache) > lru.capacity {
        removed := lru.removeTail()
        delete(lru.cache, removed.key)
    }
}

func (lru *LRUCache) moveToHead(node *Node) {
    lru.removeNode(node)
    lru.addToHead(node)
}

func (lru *LRUCache) removeNode(node *Node) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (lru *LRUCache) addToHead(node *Node) {
    node.next = lru.head.next
    node.prev = lru.head
    lru.head.next.prev = node
    lru.head.next = node
}

func (lru *LRUCache) removeTail() *Node {
    node := lru.tail.prev
    lru.removeNode(node)
    return node
}
```

**163. 布隆过滤器的原理和应用？**

**答案：**
**原理：**
使用多个哈希函数将元素映射到位数组，判断元素是否存在。

**实现：**
```go
type BloomFilter struct {
    bits      []bool
    size      int
    hashFuncs int
}

func NewBloomFilter(size, hashFuncs int) *BloomFilter {
    return &BloomFilter{
        bits:      make([]bool, size),
        size:      size,
        hashFuncs: hashFuncs,
    }
}

func (bf *BloomFilter) Add(item string) {
    for i := 0; i < bf.hashFuncs; i++ {
        hash := bf.hash(item, i)
        bf.bits[hash] = true
    }
}

func (bf *BloomFilter) Contains(item string) bool {
    for i := 0; i < bf.hashFuncs; i++ {
        hash := bf.hash(item, i)
        if !bf.bits[hash] {
            return false
        }
    }
    return true
}

func (bf *BloomFilter) hash(item string, seed int) int {
    h := fnv.New64a()
    h.Write([]byte(item))
    h.Write([]byte{byte(seed)})
    return int(h.Sum64() % uint64(bf.size))
}
```

**应用场景：**
- 缓存穿透防护
- URL去重
- 垃圾邮件过滤
- 爬虫URL去重

**164. 跳表的原理？**

**答案：**
**原理：**
多层链表，上层是下层的快速通道。

**实现：**
```go
type SkipList struct {
    head   *Node
    level  int
    maxLevel int
}

type Node struct {
    value int
    next  []*Node
}

func NewSkipList(maxLevel int) *SkipList {
    return &SkipList{
        head:     &Node{next: make([]*Node, maxLevel)},
        level:    0,
        maxLevel: maxLevel,
    }
}

func (sl *SkipList) Search(target int) bool {
    curr := sl.head

    for i := sl.level; i >= 0; i-- {
        for curr.next[i] != nil && curr.next[i].value < target {
            curr = curr.next[i]
        }
    }

    curr = curr.next[0]
    return curr != nil && curr.value == target
}

func (sl *SkipList) Insert(value int) {
    update := make([]*Node, sl.maxLevel)
    curr := sl.head

    for i := sl.level; i >= 0; i-- {
        for curr.next[i] != nil && curr.next[i].value < value {
            curr = curr.next[i]
        }
        update[i] = curr
    }

    level := sl.randomLevel()
    if level > sl.level {
        for i := sl.level + 1; i <= level; i++ {
            update[i] = sl.head
        }
        sl.level = level
    }

    node := &Node{value: value, next: make([]*Node, level+1)}
    for i := 0; i <= level; i++ {
        node.next[i] = update[i].next[i]
        update[i].next[i] = node
    }
}

func (sl *SkipList) randomLevel() int {
    level := 0
    for rand.Float64() < 0.5 && level < sl.maxLevel-1 {
        level++
    }
    return level
}
```

**165. 红黑树的特性？**

**答案：**
**五大特性：**
1. 节点是红色或黑色
2. 根节点是黑色
3. 叶子节点（NIL）是黑色
4. 红色节点的子节点必须是黑色
5. 从任一节点到叶子的所有路径包含相同数量的黑色节点

**时间复杂度：**
- 查找：O(logn)
- 插入：O(logn)
- 删除：O(logn)

**应用：**
- Java TreeMap
- C++ map
- Linux进程调度
