## 六、容器与云原生

### 1. Docker

**129. Docker的核心概念？镜像、容器、仓库的关系？**

**答案：**
**核心概念：**
- **镜像（Image）**：只读模板，包含运行应用所需的一切
- **容器（Container）**：镜像的运行实例
- **仓库（Repository）**：存储和分发镜像的地方

**关系：**
```
仓库（Docker Hub）
    ↓ pull
镜像（Image）
    ↓ run
容器（Container）
    ↓ commit
新镜像
```

**镜像特点：**
- 分层存储（Union FS）
- 只读层 + 可写层
- 共享基础层，节省空间

**示例：**
```bash
# 拉取镜像
docker pull nginx:latest

# 查看镜像
docker images

# 运行容器
docker run -d -p 80:80 nginx

# 查看容器
docker ps

# 提交容器为镜像
docker commit container_id my-nginx:v1

# 推送镜像
docker push my-nginx:v1
```

**130. Dockerfile的最佳实践？如何优化镜像大小？**

**答案：**
**最佳实践：**

```dockerfile
# 1. 使用官方基础镜像
FROM golang:1.21-alpine AS builder

# 2. 设置工作目录
WORKDIR /app

# 3. 先复制依赖文件（利用缓存）
COPY go.mod go.sum ./
RUN go mod download

# 4. 再复制源码
COPY . .

# 5. 编译
RUN CGO_ENABLED=0 GOOS=linux go build -o main .

# 6. 多阶段构建
FROM alpine:latest

# 7. 安装必要工具
RUN apk --no-cache add ca-certificates

# 8. 创建非root用户
RUN addgroup -g 1000 app && \
    adduser -D -u 1000 -G app app

# 9. 设置工作目录
WORKDIR /app

# 10. 复制编译产物
COPY --from=builder /app/main .

# 11. 切换用户
USER app

# 12. 暴露端口
EXPOSE 8080

# 13. 健康检查
HEALTHCHECK --interval=30s --timeout=3s \
  CMD wget --quiet --tries=1 --spider http://localhost:8080/health || exit 1

# 14. 启动命令
CMD ["./main"]
```

**优化镜像大小：**

1. **使用Alpine基础镜像：**
```dockerfile
FROM alpine:latest  # 5MB vs ubuntu:latest 72MB
```

2. **多阶段构建：**
```dockerfile
# 构建阶段
FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
RUN go build -o main .

# 运行阶段
FROM alpine:latest
COPY --from=builder /app/main .
CMD ["./main"]
```

3. **合并RUN命令：**
```dockerfile
# 差：多层
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get clean

# 好：单层
RUN apt-get update && \
    apt-get install -y curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

4. **使用.dockerignore：**
```
.git
.gitignore
node_modules
*.md
.env
```

5. **清理缓存：**
```dockerfile
RUN go build -o main . && \
    rm -rf /root/.cache
```

**131. Docker的网络模式有哪些？**

**答案：**
**网络模式：**

1. **bridge（默认）**：
```bash
docker run -d --network bridge nginx
```
- 容器有独立IP
- 通过NAT访问外网
- 容器间可通过IP通信

2. **host**：
```bash
docker run -d --network host nginx
```
- 容器使用宿主机网络
- 性能最好
- 端口冲突风险

3. **none**：
```bash
docker run -d --network none nginx
```
- 容器无网络
- 完全隔离
- 需要手动配置

4. **container**：
```bash
docker run -d --network container:nginx_container app
```
- 共享其他容器的网络
- 用于sidecar模式

5. **自定义网络**：
```bash
# 创建网络
docker network create my-network

# 使用网络
docker run -d --network my-network --name web nginx
docker run -d --network my-network --name app myapp

# 容器间通过名称通信
curl http://web:80
```

**网络命令：**
```bash
# 查看网络
docker network ls

# 查看网络详情
docker network inspect bridge

# 连接容器到网络
docker network connect my-network container_id

# 断开连接
docker network disconnect my-network container_id
```

**132. Docker的存储驱动？**

**答案：**
**存储驱动类型：**

1. **overlay2（推荐）**：
- 性能好
- 支持多层
- Linux 4.0+

2. **aufs**：
- 旧版Ubuntu默认
- 性能较差
- 已逐渐淘汰

3. **devicemapper**：
- CentOS/RHEL默认
- 性能一般
- 配置复杂

4. **btrfs**：
- 需要btrfs文件系统
- 支持快照
- 性能一般

5. **zfs**：
- 需要zfs文件系统
- 功能强大
- 资源消耗大

**查看存储驱动：**
```bash
docker info | grep "Storage Driver"
```

**数据持久化：**

1. **Volume（推荐）**：
```bash
# 创建volume
docker volume create my-data

# 使用volume
docker run -d -v my-data:/data nginx

# 查看volume
docker volume ls
docker volume inspect my-data
```

2. **Bind Mount**：
```bash
# 挂载宿主机目录
docker run -d -v /host/path:/container/path nginx
```

3. **tmpfs**：
```bash
# 内存文件系统
docker run -d --tmpfs /tmp nginx
```

**对比：**
| 类型 | 管理 | 性能 | 适用场景 |
|------|------|------|----------|
| Volume | Docker管理 | 好 | 数据持久化 |
| Bind Mount | 用户管理 | 好 | 开发调试 |
| tmpfs | 内存 | 最好 | 临时数据 |

**133. 多阶段构建的作用？**

**答案：**
**作用：**
1. 减小镜像大小
2. 分离构建和运行环境
3. 提高安全性
4. 简化Dockerfile

**示例：**

**单阶段（差）：**
```dockerfile
FROM golang:1.21
WORKDIR /app
COPY . .
RUN go build -o main .
CMD ["./main"]
# 镜像大小：800MB+
```

**多阶段（好）：**
```dockerfile
# 构建阶段
FROM golang:1.21 AS builder
WORKDIR /app
COPY . .
RUN go build -o main .

# 运行阶段
FROM alpine:latest
WORKDIR /app
COPY --from=builder /app/main .
CMD ["./main"]
# 镜像大小：10MB
```

**复杂示例：**
```dockerfile
# 阶段1：依赖安装
FROM node:16 AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# 阶段2：构建
FROM node:16 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# 阶段3：运行
FROM node:16-alpine
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY package*.json ./
USER node
CMD ["node", "dist/main.js"]
```

**指定构建阶段：**
```bash
# 只构建到builder阶段
docker build --target builder -t myapp:builder .

# 构建完整镜像
docker build -t myapp:latest .
```

**优势：**
- 镜像大小减少90%+
- 不包含构建工具
- 提高安全性
- 加快部署速度

### 2. Kubernetes

**134. K8s的核心组件及其作用？**

**答案：**
**控制平面组件：**

1. **kube-apiserver**：
   - API网关，所有操作的入口
   - 认证、授权、准入控制
   - 与etcd交互

2. **etcd**：
   - 分布式KV存储
   - 存储集群所有数据
   - 使用Raft协议保证一致性

3. **kube-scheduler**：
   - 调度Pod到合适的Node
   - 考虑资源、亲和性、污点等

4. **kube-controller-manager**：
   - 运行各种控制器
   - Node控制器、Deployment控制器等
   - 维护集群期望状态

5. **cloud-controller-manager**：
   - 与云平台交互
   - 管理负载均衡、存储等

**Node组件：**

1. **kubelet**：
   - Node代理
   - 管理Pod生命周期
   - 上报Node状态

2. **kube-proxy**：
   - 网络代理
   - 实现Service负载均衡
   - 维护iptables/ipvs规则

3. **容器运行时**：
   - Docker、containerd、CRI-O
   - 运行容器

**135. Pod的生命周期？**

**答案：**
**Pod阶段：**
1. **Pending**：已创建，等待调度
2. **Running**：已调度，容器运行中
3. **Succeeded**：所有容器成功终止
4. **Failed**：至少一个容器失败
5. **Unknown**：无法获取状态

**生命周期流程：**
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: lifecycle-demo
spec:
  initContainers:
  - name: init
    image: busybox
    command: ['sh', '-c', 'echo init']

  containers:
  - name: main
    image: nginx
    lifecycle:
      postStart:
        exec:
          command: ["/bin/sh", "-c", "echo postStart"]
      preStop:
        exec:
          command: ["/bin/sh", "-c", "sleep 15"]
    livenessProbe:
      httpGet:
        path: /health
        port: 80
      initialDelaySeconds: 3
      periodSeconds: 3
    readinessProbe:
      httpGet:
        path: /ready
        port: 80
      initialDelaySeconds: 5
      periodSeconds: 5
```

**探针类型：**
- **livenessProbe**：存活探针，失败则重启
- **readinessProbe**：就绪探针，失败则移出Service
- **startupProbe**：启动探针，慢启动应用

**136. Deployment、StatefulSet、DaemonSet的区别？**

**答案：**
| 特性 | Deployment | StatefulSet | DaemonSet |
|------|-----------|-------------|-----------|
| **用途** | 无状态应用 | 有状态应用 | 每个Node一个Pod |
| **Pod名称** | 随机 | 有序（0,1,2） | 随机 |
| **存储** | 共享 | 独立PVC | 本地或共享 |
| **网络** | 随机IP | 稳定hostname | 随机IP |
| **扩缩容** | 并行 | 有序 | 自动 |
| **更新** | 滚动更新 | 有序更新 | 滚动更新 |

**Deployment示例：**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
```

**StatefulSet示例：**
```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
spec:
  serviceName: mysql
  replicas: 3
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
```

**DaemonSet示例：**
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd
spec:
  selector:
    matchLabels:
      app: fluentd
  template:
    metadata:
      labels:
        app: fluentd
    spec:
      containers:
      - name: fluentd
        image: fluentd:latest
```

**137. Service的类型？如何实现服务发现？**

**答案：**
**Service类型：**

1. **ClusterIP（默认）**：
```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: ClusterIP
  selector:
    app: nginx
  ports:
  - port: 80
    targetPort: 8080
```
- 集群内部访问
- 虚拟IP

2. **NodePort**：
```yaml
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: 8080
    nodePort: 30080
```
- 通过Node IP:NodePort访问
- 端口范围：30000-32767

3. **LoadBalancer**：
```yaml
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 8080
```
- 云平台负载均衡器
- 自动分配外部IP

4. **ExternalName**：
```yaml
spec:
  type: ExternalName
  externalName: api.example.com
```
- DNS CNAME记录
- 访问外部服务

**服务发现：**
1. **环境变量**：自动注入
2. **DNS**：`service-name.namespace.svc.cluster.local`

**138. Ingress的作用？**

**答案：**
**作用：**
- HTTP/HTTPS路由
- 域名访问
- SSL终止
- 负载均衡

**示例：**
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - example.com
    secretName: tls-secret
  rules:
  - host: example.com
    http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 80
      - path: /web
        pathType: Prefix
        backend:
          service:
            name: web-service
            port:
              number: 80
```

**Ingress Controller：**
- Nginx Ingress
- Traefik
- HAProxy

**139. ConfigMap和Secret的区别？**

**答案：**
| 特性 | ConfigMap | Secret |
|------|-----------|--------|
| **用途** | 配置数据 | 敏感数据 |
| **编码** | 明文 | Base64 |
| **大小限制** | 1MB | 1MB |
| **挂载** | 文件/环境变量 | 文件/环境变量 |

**ConfigMap：**
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  app.conf: |
    server {
      listen 80;
    }
  LOG_LEVEL: "info"
```

**Secret：**
```yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
type: Opaque
data:
  username: YWRtaW4=  # base64
  password: cGFzc3dvcmQ=
```

**使用：**
```yaml
spec:
  containers:
  - name: app
    env:
    - name: LOG_LEVEL
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: LOG_LEVEL
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: db-secret
          key: password
    volumeMounts:
    - name: config
      mountPath: /etc/config
  volumes:
  - name: config
    configMap:
      name: app-config
```

**140. 如何实现自动扩缩容（HPA）？**

**答案：**
```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: app
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 15
```

**自定义指标：**
```yaml
metrics:
- type: Pods
  pods:
    metric:
      name: http_requests_per_second
    target:
      type: AverageValue
      averageValue: "1000"
```

**141. 如何实现滚动更新和回滚？**

**答案：**
**滚动更新：**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
spec:
  replicas: 10
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 2        # 最多超出2个
      maxUnavailable: 1  # 最多1个不可用
  template:
    spec:
      containers:
      - name: app
        image: app:v2
```

**更新命令：**
```bash
# 更新镜像
kubectl set image deployment/app app=app:v2

# 查看更新状态
kubectl rollout status deployment/app

# 查看历史
kubectl rollout history deployment/app

# 回滚到上一版本
kubectl rollout undo deployment/app

# 回滚到指定版本
kubectl rollout undo deployment/app --to-revision=2

# 暂停更新
kubectl rollout pause deployment/app

# 恢复更新
kubectl rollout resume deployment/app
```

**142. K8s的调度策略？**

**答案：**
**调度流程：**
1. **预选（Predicate）**：过滤不符合条件的Node
2. **优选（Priority）**：给Node打分
3. **选定（Select）**：选择分数最高的Node

**调度策略：**

1. **nodeSelector**：
```yaml
spec:
  nodeSelector:
    disktype: ssd
```

2. **亲和性（Affinity）**：
```yaml
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: zone
            operator: In
            values:
            - zone1
            - zone2
    podAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchLabels:
              app: cache
          topologyKey: kubernetes.io/hostname
```

3. **污点和容忍（Taint & Toleration）**：
```bash
# 添加污点
kubectl taint nodes node1 key=value:NoSchedule

# Pod容忍
spec:
  tolerations:
  - key: "key"
    operator: "Equal"
    value: "value"
    effect: "NoSchedule"
```

4. **优先级（Priority）**：
```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000
globalDefault: false
---
spec:
  priorityClassName: high-priority
```

**143. 如何进行资源限制和配额管理？**

**答案：**
**Pod资源限制：**
```yaml
spec:
  containers:
  - name: app
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
```

**命名空间配额：**
```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-quota
  namespace: dev
spec:
  hard:
    requests.cpu: "10"
    requests.memory: 20Gi
    limits.cpu: "20"
    limits.memory: 40Gi
    pods: "50"
    services: "10"
    persistentvolumeclaims: "20"
```

**LimitRange：**
```yaml
apiVersion: v1
kind: LimitRange
metadata:
  name: limit-range
  namespace: dev
spec:
  limits:
  - max:
      cpu: "2"
      memory: "4Gi"
    min:
      cpu: "100m"
      memory: "128Mi"
    default:
      cpu: "500m"
      memory: "512Mi"
    defaultRequest:
      cpu: "250m"
      memory: "256Mi"
    type: Container
```

**查看资源使用：**
```bash
# 查看Node资源
kubectl top nodes

# 查看Pod资源
kubectl top pods

# 查看配额
kubectl describe quota -n dev
```

---

